'use strict';

Object.defineProperty(exports, '__esModule', { value: true });

var _doc = require('prettier/doc');
var sassFormatter = require('sass-formatter');
var synckit = require('synckit');
var module$1 = require('module');

function _interopDefaultLegacy (e) { return e && typeof e === 'object' && 'default' in e ? e : { 'default': e }; }

var _doc__default = /*#__PURE__*/_interopDefaultLegacy(_doc);

const blockElementsT = [
    'address',
    'article',
    'aside',
    'blockquote',
    'details',
    'dialog',
    'dd',
    'div',
    'dl',
    'dt',
    'fieldset',
    'figcaption',
    'figure',
    'footer',
    'form',
    'h1',
    'h2',
    'h3',
    'h4',
    'h5',
    'h6',
    'header',
    'hgroup',
    'hr',
    'li',
    'main',
    'nav',
    'ol',
    'p',
    'pre',
    'section',
    'table',
    'ul',
    'title',
    'html',
];
const blockElements = [...blockElementsT];
const selfClosingTags = [
    'area',
    'base',
    'br',
    'col',
    'embed',
    'hr',
    'img',
    'input',
    'link',
    'meta',
    'param',
    'source',
    'track',
    'wbr',
];

const require$2 = module$1.createRequire((typeof document === 'undefined' ? new (require('u' + 'rl').URL)('file:' + __filename).href : (document.currentScript && document.currentScript.src || new URL('index.js', document.baseURI).href)));
const serialize = synckit.createSyncFn(require$2.resolve('../workers/serialize-worker.js'));
const formattableAttributes = [];
const isEmptyTextNode = (node) => {
    return !!node && node.type === 'text' && getUnencodedText(node).trim() === '';
};
const isPreTagContent = (path) => {
    if (!path || !path.stack || !Array.isArray(path.stack))
        return false;
    return path.stack.some((node) => (node.type === 'element' && node.name.toLowerCase() === 'pre') ||
        (node.type === 'attribute' && !formattableAttributes.includes(node.name)));
};
function getUnencodedText(node) {
    return node.value;
}
function printRaw(node, stripLeadingAndTrailingNewline = false) {
    if (!isNodeWithChildren(node)) {
        return '';
    }
    if (node.children.length === 0) {
        return '';
    }
    let raw = node.children.reduce((prev, curr) => prev + serialize(curr), '');
    if (!stripLeadingAndTrailingNewline) {
        return raw;
    }
    if (startsWithLinebreak(raw)) {
        raw = raw.substring(raw.indexOf('\n') + 1);
    }
    if (endsWithLinebreak(raw)) {
        raw = raw.substring(0, raw.lastIndexOf('\n'));
        if (raw.charAt(raw.length - 1) === '\r') {
            raw = raw.substring(0, raw.length - 1);
        }
    }
    return raw;
}
function isNodeWithChildren(node) {
    return node && 'children' in node && Array.isArray(node.children);
}
function isInlineElement(path, opts, node) {
    return (node &&
        node.type === 'element' &&
        !isBlockElement(node, opts) &&
        !isPreTagContent(path));
}
function isBlockElement(node, opts) {
    return (node &&
        node.type === 'element' &&
        opts.htmlWhitespaceSensitivity !== 'strict' &&
        (opts.htmlWhitespaceSensitivity === 'ignore' ||
            blockElements.includes(node.name)));
}
function isTextNodeStartingWithLinebreak(node, nrLines = 1) {
    return startsWithLinebreak(getUnencodedText(node), nrLines);
}
function startsWithLinebreak(text, nrLines = 1) {
    return new RegExp(`^([\\t\\f\\r ]*\\n){${nrLines}}`).test(text);
}
function endsWithLinebreak(text, nrLines = 1) {
    return new RegExp(`(\\n[\\t\\f\\r ]*){${nrLines}}$`).test(text);
}
function isTextNodeStartingWithWhitespace(node) {
    return node.type === 'text' && /^\s/.test(getUnencodedText(node));
}
function isTextNodeEndingWithWhitespace(node) {
    return node.type === 'text' && /\s$/.test(getUnencodedText(node));
}
function forceIntoExpression(statement) {
    return `(${statement}\n)`;
}
function shouldHugStart(node, opts) {
    if (isBlockElement(node, opts)) {
        return false;
    }
    if (!isNodeWithChildren(node)) {
        return false;
    }
    const children = node.children;
    if (children.length === 0) {
        return true;
    }
    const firstChild = children[0];
    return !isTextNodeStartingWithWhitespace(firstChild);
}
function shouldHugEnd(node, opts) {
    if (isBlockElement(node, opts)) {
        return false;
    }
    if (!isNodeWithChildren(node)) {
        return false;
    }
    const children = node.children;
    if (children.length === 0) {
        return true;
    }
    return false;
}
function canOmitSoftlineBeforeClosingTag(path, opts) {
    return isLastChildWithinParentBlockElement(path, opts);
}
function getChildren(node) {
    return isNodeWithChildren(node) ? node.children : [];
}
function isLastChildWithinParentBlockElement(path, opts) {
    const parent = path.getParentNode();
    if (!parent || !isBlockElement(parent, opts)) {
        return false;
    }
    const children = getChildren(parent);
    const lastChild = children[children.length - 1];
    return lastChild === path.getNode();
}
function trimTextNodeLeft(node) {
    node.value = node.value && node.value.trimStart();
}
function trimTextNodeRight(node) {
    node.value = node.value && node.value.trimEnd();
}
function manualDedent(input) {
    let minTabSize = Infinity;
    let result = input;
    result = result.replace(/\r\n/g, '\n');
    let char = '';
    for (const line of result.split('\n')) {
        if (!line)
            continue;
        if (line[0] && /^[^\s]/.test(line[0])) {
            minTabSize = 0;
            break;
        }
        const match = line.match(/^(\s+)\S+/);
        if (match) {
            if (match[1] && !char)
                char = match[1][0];
            if (match[1].length < minTabSize)
                minTabSize = match[1].length;
        }
    }
    if (minTabSize > 0 && Number.isFinite(minTabSize)) {
        result = result.replace(new RegExp(`^${new Array(minTabSize + 1).join(char)}`, 'gm'), '');
    }
    return {
        tabSize: minTabSize === Infinity ? 0 : minTabSize,
        char,
        result,
    };
}
function getMarkdownName(script) {
    let defaultMatch;
    while ((defaultMatch =
        /import\s+([^\s]+)\s+from\s+['|"|`]astro\/components\/Markdown\.astro/g.exec(script))) {
        if (defaultMatch[1])
            return new Set([defaultMatch[1].trim()]);
    }
    let namedMatch;
    while ((namedMatch =
        /import\s+\{\s*([^}]+)\}\s+from\s+['|"|`]astro\/components/g.exec(script))) {
        if (namedMatch[1] && !namedMatch[1].includes('Markdown'))
            continue;
        const rawImports = namedMatch[1]
            .trim()
            .replace(/^\{/, '')
            .replace(/\}$/, '')
            .trim();
        let importName = 'Markdown';
        for (const spec of rawImports.split(',')) {
            const [original, renamed] = spec.split(' as ').map((s) => s.trim());
            if (original !== 'Markdown')
                continue;
            importName = renamed || original;
            break;
        }
        return new Set([importName]);
    }
    return new Set(['Markdown']);
}
function isTextNode(node) {
    return node.type === 'text';
}
function removeDuplicates(root) {
    root.children = root.children.filter((node, i, rootChildren) => {
        if (node.type !== 'text')
            return true;
        return (i ===
            rootChildren.findIndex((t) => {
                if (t.position && node.position) {
                    return (node.type === 'text' &&
                        t.position.start.offset === node.position.start.offset &&
                        t.position.start.line === node.position.start.line &&
                        t.position.start.column === node.position.start.column);
                }
            }));
    });
}
function isTagLikeNode(node) {
    return (node.type === 'element' ||
        node.type === 'component' ||
        node.type === 'custom-element' ||
        node.type === 'fragment');
}
function getSiblings(path) {
    const parent = path.getParentNode();
    if (!parent)
        return [];
    return getChildren(parent);
}
function getNextNode(path) {
    var _a, _b, _c, _d;
    const node = path.getNode();
    if (node) {
        const siblings = getSiblings(path);
        if (((_a = node.position) === null || _a === void 0 ? void 0 : _a.start) === ((_b = siblings[siblings.length - 1].position) === null || _b === void 0 ? void 0 : _b.start))
            return null;
        for (let i = 0; i < siblings.length; i++) {
            const sibling = siblings[i];
            if (((_c = sibling.position) === null || _c === void 0 ? void 0 : _c.start) === ((_d = node.position) === null || _d === void 0 ? void 0 : _d.start) &&
                i !== siblings.length - 1) {
                return siblings[i + 1];
            }
        }
    }
    return null;
}

const { builders: { breakParent, dedent, fill, group, hardline, indent, join, line, literalline, softline, }, utils: { removeLines, stripTrailingHardline }, } = _doc__default["default"];
function printComment(commentPath, options) {
    return commentPath;
}
function print(path, opts, print) {
    const node = path.getValue();
    if (!node) {
        return '';
    }
    if (typeof node === 'string') {
        return node;
    }
    switch (node.type) {
        case 'root': {
            removeDuplicates(node);
            return [stripTrailingHardline(path.map(print, 'children')), hardline];
        }
        case 'text': {
            const rawText = getUnencodedText(node);
            if (isEmptyTextNode(node)) {
                const hasWhiteSpace = rawText.trim().length < getUnencodedText(node).length;
                const hasOneOrMoreNewlines = /\n/.test(getUnencodedText(node));
                const hasTwoOrMoreNewlines = /\n\r?\s*\n\r?/.test(getUnencodedText(node));
                if (hasTwoOrMoreNewlines) {
                    return [hardline, hardline];
                }
                if (hasOneOrMoreNewlines) {
                    return hardline;
                }
                if (hasWhiteSpace) {
                    return line;
                }
                return '';
            }
            return fill(splitTextToDocs(node));
        }
        case 'component':
        case 'fragment':
        case 'element': {
            let isEmpty;
            if (!node.children) {
                isEmpty = true;
            }
            else {
                isEmpty = node.children.every((child) => isEmptyTextNode(child));
            }
            const isSelfClosingTag = isEmpty &&
                (node.type !== 'element' || selfClosingTags.indexOf(node.name) !== -1);
            const attributes = path.map(print, 'attributes');
            if (isSelfClosingTag) {
                return group(['<', node.name, indent(group(attributes)), line, `/>`]);
            }
            if (node.children) {
                const children = node.children;
                const firstChild = children[0];
                const lastChild = children[children.length - 1];
                let noHugSeparatorStart = softline;
                let noHugSeparatorEnd = softline;
                const hugStart = shouldHugStart(node, opts);
                const hugEnd = shouldHugEnd(node, opts);
                let body;
                if (isEmpty) {
                    body =
                        isInlineElement(path, opts, node) &&
                            node.children.length &&
                            isTextNodeStartingWithWhitespace(node.children[0]) &&
                            !isPreTagContent(path)
                            ? () => line
                            :
                                () => softline;
                }
                else if (isPreTagContent(path)) {
                    body = () => printRaw(node);
                }
                else if (isInlineElement(path, opts, node) &&
                    !isPreTagContent(path)) {
                    body = () => path.map(print, 'children');
                }
                else {
                    body = () => path.map(print, 'children');
                }
                const openingTag = [
                    '<',
                    node.name,
                    indent(group([
                        ...attributes,
                        hugStart
                            ? ''
                            : !isPreTagContent(path) && !opts.bracketSameLine
                                ? dedent(softline)
                                : '',
                    ])),
                ];
                if (hugStart && hugEnd) {
                    const huggedContent = [
                        softline,
                        group(['>', body(), `</${node.name}`]),
                    ];
                    const omitSoftlineBeforeClosingTag = isEmpty || canOmitSoftlineBeforeClosingTag(path, opts);
                    return group([
                        ...openingTag,
                        isEmpty ? group(huggedContent) : group(indent(huggedContent)),
                        omitSoftlineBeforeClosingTag ? '' : softline,
                        '>',
                    ]);
                }
                if (isPreTagContent(path)) {
                    noHugSeparatorStart = '';
                    noHugSeparatorEnd = '';
                }
                else {
                    let didSetEndSeparator = false;
                    if (!hugStart && firstChild && isTextNode(firstChild)) {
                        if (isTextNodeStartingWithLinebreak(firstChild) &&
                            firstChild !== lastChild &&
                            (!isInlineElement(path, opts, node) ||
                                isTextNodeEndingWithWhitespace(lastChild))) {
                            noHugSeparatorStart = hardline;
                            noHugSeparatorEnd = hardline;
                            didSetEndSeparator = true;
                        }
                        else if (isInlineElement(path, opts, node)) {
                            noHugSeparatorStart = line;
                        }
                        trimTextNodeLeft(firstChild);
                    }
                    if (!hugEnd && lastChild && isTextNode(lastChild)) {
                        if (isInlineElement(path, opts, node) && !didSetEndSeparator) {
                            noHugSeparatorEnd = softline;
                        }
                        trimTextNodeRight(lastChild);
                    }
                }
                if (hugStart) {
                    return group([
                        ...openingTag,
                        indent([softline, group(['>', body()])]),
                        noHugSeparatorEnd,
                        `</${node.name}>`,
                    ]);
                }
                if (hugEnd) {
                    return group([
                        ...openingTag,
                        '>',
                        indent([noHugSeparatorStart, group([body(), `</${node.name}`])]),
                        canOmitSoftlineBeforeClosingTag(path, opts) ? '' : softline,
                        '>',
                    ]);
                }
                if (isEmpty) {
                    return group([...openingTag, '>', body(), `</${node.name}>`]);
                }
                return group([
                    ...openingTag,
                    '>',
                    indent([noHugSeparatorStart, body()]),
                    noHugSeparatorEnd,
                    `</${node.name}>`,
                ]);
            }
            return '';
        }
        case 'attribute': {
            const name = node.name.trim();
            const quote = opts.singleQuote ? "'" : '"';
            switch (node.kind) {
                case 'empty':
                    return [line, name];
                case 'expression':
                    return '';
                case 'quoted':
                    return [line, name, '=', quote, node.value, quote];
                case 'shorthand':
                    return [line, '{', name, '}'];
                case 'spread':
                    return [line, '{...', name, '}'];
                case 'template-literal':
                    return [line, name, '=', '`', node.value, '`'];
            }
            return '';
        }
        case 'doctype': {
            return ['<!DOCTYPE html>', hardline];
        }
        case 'comment':
            const nextNode = getNextNode(path);
            let trailingLine = '';
            if (nextNode && isTagLikeNode(nextNode)) {
                trailingLine = hardline;
            }
            return ['<!--', getUnencodedText(node), '-->', trailingLine];
        default: {
            throw new Error(`Unhandled node type "${node.type}"!`);
        }
    }
}
function splitTextToDocs(node) {
    const text = getUnencodedText(node);
    const textLines = text.split(/[\t\n\f\r ]+/);
    let docs = join(line, textLines).parts.filter((s) => s !== '');
    if (startsWithLinebreak(text)) {
        docs[0] = hardline;
    }
    if (startsWithLinebreak(text, 2)) {
        docs = [hardline, ...docs];
    }
    if (endsWithLinebreak(text)) {
        docs[docs.length - 1] = hardline;
    }
    if (endsWithLinebreak(text, 2)) {
        docs = [...docs, hardline];
    }
    return docs;
}
function expressionParser(text, parsers, opts) {
    const ast = parsers.babel(text, opts);
    return { ...ast, program: ast.program.body[0].expression };
}
let markdownComponentName = new Set();
function embed(path, print, textToDoc, opts) {
    if (!opts.__astro)
        opts.__astro = {};
    const node = path.getValue();
    if (!node)
        return null;
    if (node.type === 'expression') {
        const textContent = printRaw(node);
        let content;
        content = textToDoc(forceIntoExpression(textContent), {
            ...opts,
            parser: expressionParser,
            semi: false,
        });
        content = stripTrailingHardline(content);
        return [
            '{',
            content,
            '}',
        ];
    }
    if (node.type === 'attribute' && node.kind === 'expression') {
        const value = node.value.trim();
        const name = node.name.trim();
        let attrNodeValue = textToDoc(forceIntoExpression(value), {
            ...opts,
            parser: expressionParser,
            semi: false,
        });
        attrNodeValue = stripTrailingHardline(attrNodeValue);
        if (name === value && opts.astroAllowShorthand) {
            return [line, '{', attrNodeValue, '}'];
        }
        return [line, name, '=', '{', attrNodeValue, '}'];
    }
    if (node.type === 'frontmatter') {
        markdownComponentName = getMarkdownName(node.value);
        return [
            group([
                '---',
                hardline,
                textToDoc(node.value, { ...opts, parser: 'typescript' }),
                '---',
                hardline,
            ]),
            hardline,
        ];
    }
    if (node.type === 'element' && node.name === 'script') {
        const scriptContent = printRaw(node);
        let formatttedScript = textToDoc(scriptContent, {
            ...opts,
            parser: 'typescript',
        });
        formatttedScript = stripTrailingHardline(formatttedScript);
        const attributes = path.map(print, 'attributes');
        const openingTag = group([
            '<script',
            indent(group(attributes)),
            softline,
            '>',
        ]);
        return [
            openingTag,
            indent([hardline, formatttedScript]),
            hardline,
            '</script>',
        ];
    }
    if (node.type === 'element' && node.name === 'style') {
        const styleTagContent = printRaw(node);
        const supportedStyleLangValues = ['css', 'scss', 'sass'];
        let parserLang = 'css';
        if (node.attributes) {
            const langAttribute = node.attributes.filter((x) => x.name === 'lang');
            if (langAttribute.length) {
                const styleLang = langAttribute[0].value.toLowerCase();
                if (supportedStyleLangValues.includes(styleLang))
                    parserLang = styleLang;
            }
        }
        switch (parserLang) {
            case 'css':
            case 'scss': {
                let formattedStyles = textToDoc(styleTagContent, {
                    ...opts,
                    parser: parserLang,
                });
                formattedStyles = stripTrailingHardline(formattedStyles);
                const attributes = path.map(print, 'attributes');
                const openingTag = group([
                    '<style',
                    indent(group(attributes)),
                    softline,
                    '>',
                ]);
                return [
                    openingTag,
                    indent([hardline, formattedStyles]),
                    hardline,
                    '</style>',
                ];
            }
            case 'sass': {
                const lineEnding = opts.endOfLine.toUpperCase() === 'CRLF' ? 'CRLF' : 'LF';
                const sassOptions = {
                    tabSize: opts.tabWidth,
                    insertSpaces: !opts.useTabs,
                    lineEnding,
                };
                const { result: raw } = manualDedent(styleTagContent);
                const formattedSassIndented = sassFormatter.SassFormatter.Format(raw, sassOptions).trim();
                const formattedSass = join(hardline, formattedSassIndented.split('\n'));
                const attributes = path.map(print, 'attributes');
                const openingTag = group([
                    '<style',
                    indent(group(attributes)),
                    softline,
                    '>',
                ]);
                return [
                    openingTag,
                    indent(group([hardline, formattedSass])),
                    hardline,
                    '</style>',
                ];
            }
        }
    }
    if (node.type === 'component' && markdownComponentName.has(node.name)) {
        let content = printRaw(node);
        content = content.replace(/\r\n/g, '\n');
        const contentArr = content.split('\n').map((s) => s.trimStart());
        content = contentArr.join('\n');
        let formatttedMarkdown = textToDoc(content, {
            ...opts,
            parser: 'markdown',
        });
        formatttedMarkdown = stripTrailingHardline(formatttedMarkdown);
        const attributes = path.map(print, 'attributes');
        const openingTag = group([
            `<${node.name}`,
            indent(group(attributes)),
            softline,
            '>',
        ]);
        return [
            openingTag,
            indent(group([hardline, formatttedMarkdown])),
            hardline,
            `</${node.name}>`,
        ];
    }
    return null;
}
function hasPrettierIgnore(path) {
    return false;
}
const printer = {
    print,
    printComment,
    embed,
    hasPrettierIgnore,
};

const options = {
    astroSortOrder: {
        since: '0.0.1',
        category: 'Astro',
        type: 'choice',
        default: 'markup | styles',
        description: 'Sort order for markup, scripts, and styles',
        choices: [
            {
                value: 'markup | styles',
                description: 'markup | styles',
            },
            {
                value: 'styles | markup',
                description: 'styles | markup',
            },
        ],
    },
    astroAllowShorthand: {
        since: '0.0.10',
        category: 'Astro',
        type: 'boolean',
        default: false,
        description: 'Enable/disable attribute shorthand if attribute name and expression are the same',
    },
};

const require$1 = module$1.createRequire((typeof document === 'undefined' ? new (require('u' + 'rl').URL)('file:' + __filename).href : (document.currentScript && document.currentScript.src || new URL('index.js', document.baseURI).href)));
const parse = synckit.createSyncFn(require$1.resolve('../workers/parse-worker.js'));
const languages = [
    {
        name: 'astro',
        parsers: ['astro'],
        extensions: ['.astro'],
        vscodeLanguageIds: ['astro'],
    },
];
const parsers = {
    astro: {
        parse: (source) => parse(source),
        astFormat: 'astro',
        locStart: (node) => node.start,
        locEnd: (node) => node.end,
    },
};
const printers = {
    astro: printer,
};
const defaultOptions = {
    tabWidth: 2,
};

exports.defaultOptions = defaultOptions;
exports.languages = languages;
exports.options = options;
exports.parsers = parsers;
exports.printers = printers;
//# sourceMappingURL=index.js.map
