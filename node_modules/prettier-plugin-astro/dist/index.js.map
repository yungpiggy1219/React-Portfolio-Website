{"version":3,"file":"index.js","sources":["../src/nodes.ts","../src/utils.ts","../src/printer.ts","../src/options.ts","../src/index.ts"],"sourcesContent":["import {\n  Node,\n  AttributeNode,\n  RootNode,\n  ElementNode,\n  ComponentNode,\n  CustomElementNode,\n  ExpressionNode,\n  TextNode,\n  FrontmatterNode,\n  DoctypeNode,\n  CommentNode,\n  FragmentNode,\n} from '@astrojs/compiler/types';\n\n// MISSING ATTRIBUTE NODE FROM THE NODE TYPE\n\nexport interface NodeWithText {\n  value: string;\n}\n\n// export interface Ast {\n//   html: anyNode;\n//   css: StyleNode[];\n//   module: ScriptNode;\n//   meta: {\n//     features: number;\n//   };\n// }\n\n// export interface BaseNode {\n//   start: number;\n//   end: number;\n//   type: string;\n//   children?: anyNode[];\n//   // TODO: ADD BETTER TYPE\n//   [prop_name: string]: any;\n// }\n\n// export type attributeValue = TextNode[] | AttributeShorthandNode[] | MustacheTagNode[] | true;\n\nexport interface NodeWithChildren {\n  // children: anyNode[];\n  children: Node[];\n}\n\n// export interface NodeWithText {\n//   data: string;\n//   raw?: string;\n// }\n\n// export interface FragmentNode extends BaseNode {\n//   type: 'Fragment';\n//   children: anyNode[];\n// }\n\n// export interface TextNode extends BaseNode {\n//   type: 'Text';\n//   data: string;\n//   raw: string;\n// }\n\n// export interface CodeFenceNode extends BaseNode {\n//   type: 'CodeFence';\n//   metadata: string;\n//   data: string;\n//   raw: string;\n// }\n\n// export interface CodeSpanNode extends BaseNode {\n//   type: 'CodeSpan';\n//   metadata: string;\n//   data: string;\n//   raw: string;\n// }\n\n// export interface SpreadNode extends BaseNode {\n//   type: 'Spread';\n//   expression: ExpressionNode;\n// }\n\n// export interface ExpressionNode {\n//   type: 'Expression';\n//   start: number;\n//   end: number;\n//   codeChunks: string[];\n//   children: anyNode[];\n// }\n\n// export interface ScriptNode extends BaseNode {\n//   type: 'Script';\n//   context: 'runtime' | 'setup';\n//   content: string;\n// }\n\n// export interface StyleNode extends BaseNode {\n//   type: 'Style';\n//   // TODO: ADD BETTER TYPE\n//   attributes: any[];\n//   content: {\n//     start: number;\n//     end: number;\n//     styles: string;\n//   };\n// }\n\n// export interface AttributeNode extends BaseNode {\n//   type: 'Attribute';\n//   name: string;\n//   value: attributeValue;\n// }\n\n// export interface AttributeShorthandNode extends BaseNode {\n//   type: 'AttributeShorthand';\n//   expression: IdentifierNode;\n// }\n\n// export interface IdentifierNode extends BaseNode {\n//   type: 'Identifier';\n//   name: string;\n// }\n\n// export interface MustacheTagNode extends BaseNode {\n//   type: 'MustacheTag';\n//   expression: ExpressionNode;\n// }\n\n// export interface SlotNode extends BaseNode {\n//   type: 'Slot';\n//   name: string;\n//   attributes: AttributeNode[];\n// }\n\n// export interface CommentNode extends BaseNode {\n//   type: 'Comment';\n//   data: string;\n//   name?: string;\n//   leading?: boolean;\n//   trailing?: boolean;\n//   printed?: boolean;\n//   nodeDescription?: string;\n// }\n\n// export interface ElementNode extends BaseNode {\n//   type: 'Element';\n//   name: string;\n//   attributes: AttributeNode[];\n// }\n\n// export interface InlineComponentNode extends BaseNode {\n//   type: 'InlineComponent';\n//   name: string;\n//   attributes: AttributeNode[];\n// }\n\nexport interface BlockElementNode extends ElementNode {\n  name: typeof blockElementsT[number];\n}\n\nexport interface InlineElementNode extends ElementNode {\n  name: typeof inlineElementsT[number];\n}\n\n// https://developer.mozilla.org/en-US/docs/Web/HTML/Block-level_elements#Elements\nconst blockElementsT = [\n  'address',\n  'article',\n  'aside',\n  'blockquote',\n  'details',\n  'dialog',\n  'dd',\n  'div',\n  'dl',\n  'dt',\n  'fieldset',\n  'figcaption',\n  'figure',\n  'footer',\n  'form',\n  'h1',\n  'h2',\n  'h3',\n  'h4',\n  'h5',\n  'h6',\n  'header',\n  'hgroup',\n  'hr',\n  'li',\n  'main',\n  'nav',\n  'ol',\n  'p',\n  'pre',\n  'section',\n  'table',\n  'ul',\n  // TODO: WIP\n  'title',\n  'html',\n] as const;\n// https://github.com/microsoft/TypeScript/issues/31018\nexport const blockElements: string[] = [...blockElementsT];\n\n// https://developer.mozilla.org/en-US/docs/Web/HTML/Inline_elements\nconst inlineElementsT = [\n  'a',\n  'abbr',\n  'acronym',\n  'audio',\n  'b',\n  'bdi',\n  'bdo',\n  'big',\n  'br',\n  'button',\n  'canvas',\n  'cite',\n  'code',\n  'data',\n  'datalist',\n  'del',\n  'dfn',\n  'em',\n  'embed',\n  'i',\n  'iframe',\n  'img',\n  'input',\n  'ins',\n  'kbd',\n  'label',\n  'map',\n  'mark',\n  'meter',\n  'noscript',\n  'object',\n  'output',\n  'picture',\n  'progress',\n  'q',\n  'ruby',\n  's',\n  'samp',\n  'script',\n  'select',\n  'slot',\n  'small',\n  'span',\n  'strong',\n  'sub',\n  'sup',\n  'svg',\n  'template',\n  'textarea',\n  'time',\n  'u',\n  'tt',\n  'var',\n  'video',\n  'wbr',\n] as const;\n// https://github.com/microsoft/TypeScript/issues/31018\nexport const inlineElements: string[] = [...inlineElementsT];\n\n// @see http://xahlee.info/js/html5_non-closing_tag.html\nexport const selfClosingTags = [\n  'area',\n  'base',\n  'br',\n  'col',\n  'embed',\n  'hr',\n  'img',\n  'input',\n  'link',\n  'meta',\n  'param',\n  'source',\n  'track',\n  'wbr',\n];\n\nexport type anyNode =\n  | RootNode\n  | AttributeNode\n  | ElementNode\n  | ComponentNode\n  | CustomElementNode\n  | ExpressionNode\n  | TextNode\n  | DoctypeNode\n  | CommentNode\n  | FragmentNode\n  | FrontmatterNode;\n\nexport type {\n  AttributeNode,\n  Node,\n  RootNode,\n  ElementNode,\n  ComponentNode,\n  CustomElementNode,\n  ExpressionNode,\n  TextNode,\n  FrontmatterNode,\n  DoctypeNode,\n  CommentNode,\n  FragmentNode,\n  TagLikeNode,\n} from '@astrojs/compiler/types';\n","import {\n  AstPath as AstP,\n  doc,\n  Doc,\n  ParserOptions as ParserOpts,\n  util,\n} from 'prettier';\n\nimport {\n  anyNode,\n  Node,\n  RootNode,\n  AttributeNode,\n  ElementNode,\n  ComponentNode,\n  CustomElementNode,\n  ExpressionNode,\n  TextNode,\n  FrontmatterNode,\n  DoctypeNode,\n  CommentNode,\n  NodeWithText,\n  blockElements,\n  // attributeValue,\n  BlockElementNode,\n  InlineElementNode,\n  // MustacheTagNode,\n  NodeWithChildren,\n  TagLikeNode,\n  // NodeWithText,\n  // TextNode,\n} from './nodes';\n\nimport { createSyncFn } from 'synckit';\nimport { createRequire } from 'module';\nconst require = createRequire(import.meta.url);\n\n// the worker path must be absolute\nconst serialize = createSyncFn(\n  require.resolve('../workers/serialize-worker.js')\n);\n\ntype ParserOptions = ParserOpts<anyNode>;\ntype AstPath = AstP<anyNode>;\n\n/**\n * HTML attributes that we may safely reformat (trim whitespace, add or remove newlines)\n */\nexport const formattableAttributes: string[] = [\n  // None at the moment\n  // Prettier HTML does not format attributes at all\n  // and to be consistent we leave this array empty for now\n];\n\n// const rootNodeKeys = new Set(['html', 'css', 'module']);\n\n// const isSync = makeSynchronous(async (node: anyNode) => {\n//   const dynamicImport = new Function('file', 'return import(file)');\n//   const { is } = await dynamicImport('@astrojs/compiler/utils');\n//   try {\n//     return await is(node);\n//   } catch (e) {\n//     console.error(e);\n//   }\n// });\n\n// export const is = (node: anyNode) => isSync(node);\n\nexport const isRootNode = (node: anyNode): node is RootNode =>\n  node.type === 'root';\n\nexport const isEmptyTextNode = (node: Node): boolean => {\n  return !!node && node.type === 'text' && getUnencodedText(node).trim() === '';\n};\n\nexport const isPreTagContent = (path: AstPath): boolean => {\n  if (!path || !path.stack || !Array.isArray(path.stack)) return false;\n  return path.stack.some(\n    (node: anyNode) =>\n      (node.type === 'element' && node.name.toLowerCase() === 'pre') ||\n      (node.type === 'attribute' && !formattableAttributes.includes(node.name))\n  );\n};\n\nexport function isLoneMustacheTag(node: AttributeNode): boolean {\n  // export function isLoneMustacheTag(node: AttributeNode): node is [MustacheTagNode] {\n  return node.kind === 'expression';\n  // return node !== true && node.length === 1 && node[0].type === 'MustacheTag';\n}\n\n// function isAttributeShorthand(node: attributeValue): node is [AttributeShorthandNode] {\n//   return node !== true && node.length === 1 && node[0].type === 'AttributeShorthand';\n// }\n\n/**\n * True if node is of type `{a}` or `a={a}`\n */\nexport function isOrCanBeConvertedToShorthand(\n  node: AttributeNode,\n  opts: ParserOptions\n): boolean {\n  if (!opts.astroAllowShorthand) return false;\n  if (node.kind === 'shorthand') {\n    return true;\n  }\n  // if (isAttributeShorthand(node.value)) {\n  //   return true;\n  // }\n\n  if (node.value.trim() === node.name.trim()) {\n    return true;\n  }\n\n  // if (isLoneMustacheTag(node.value)) {\n  //   const expression = node.value[0].expression;\n  //   return expression.codeChunks[0].trim() === node.name;\n  //   // return (expression.type === 'Identifier' && expression.name === node.name) || (expression.type === 'Expression' && expression.codeChunks[0] === node.name);\n  // }\n\n  return false;\n}\n\n/**\n *  True if node is of type `{a}` and astroAllowShorthand is false\n */\nexport function isShorthandAndMustBeConvertedToBinaryExpression(\n  node: AttributeNode,\n  opts: ParserOptions\n): boolean {\n  if (opts.astroAllowShorthand) return false;\n  if (node.type === 'attribute' && node.kind === 'shorthand') {\n    return true;\n  }\n  // if (isAttributeShorthand(node.value)) {\n  //   return true;\n  // }\n  return false;\n}\n\n// export function flatten<T>(arrays: T[][]): T[] {\n//   return ([] as T[]).concat.apply([], arrays);\n// }\n\n// TODO: TEST IF IT'S GETTING THE CORRECT TEXT\nexport function getText(node: anyNode, opts: ParserOptions): string {\n  if (!node.position) return '';\n  return opts.originalText.slice(\n    node.position.start.offset + 1,\n    node.position.end?.offset\n  );\n  // return opts.originalText.slice(opts.locStart(node), opts.locEnd(node));\n}\n\nexport function getUnencodedText(node: NodeWithText): string {\n  return node.value;\n}\n\n// export function replaceEndOfLineWith(text: string, replacement: doc.builders.DocCommand): Doc[] {\n//   const parts = [];\n//   for (const part of text.split('\\n')) {\n//     if (parts.length > 0) {\n//       parts.push(replacement);\n//     }\n//     if (part.endsWith('\\r')) {\n//       parts.push(part.slice(0, -1));\n//     } else {\n//       parts.push(part);\n//     }\n//   }\n//   return parts;\n// }\n\n/**\n *  Returns the content of the node\n */\nexport function printRaw(\n  node: anyNode,\n  stripLeadingAndTrailingNewline = false\n): string {\n  if (!isNodeWithChildren(node)) {\n    return '';\n  }\n\n  if (node.children.length === 0) {\n    return '';\n  }\n\n  let raw = node.children.reduce(\n    (prev: string, curr: Node) => prev + serialize(curr),\n    ''\n  );\n\n  if (!stripLeadingAndTrailingNewline) {\n    return raw;\n  }\n\n  if (startsWithLinebreak(raw)) {\n    raw = raw.substring(raw.indexOf('\\n') + 1);\n  }\n  if (endsWithLinebreak(raw)) {\n    raw = raw.substring(0, raw.lastIndexOf('\\n'));\n    if (raw.charAt(raw.length - 1) === '\\r') {\n      raw = raw.substring(0, raw.length - 1);\n    }\n  }\n\n  return raw;\n}\n\nexport function isNodeWithChildren(\n  node: anyNode\n): node is anyNode & NodeWithChildren {\n  return node && 'children' in node && Array.isArray(node.children);\n}\n\nexport function isInlineElement(\n  path: AstPath,\n  opts: ParserOptions,\n  node: anyNode\n): node is InlineElementNode {\n  return (\n    node &&\n    node.type === 'element' &&\n    !isBlockElement(node, opts) &&\n    !isPreTagContent(path)\n  );\n}\n\nexport function isBlockElement(\n  node: anyNode,\n  opts: ParserOptions\n): node is BlockElementNode {\n  return (\n    node &&\n    node.type === 'element' &&\n    opts.htmlWhitespaceSensitivity !== 'strict' &&\n    (opts.htmlWhitespaceSensitivity === 'ignore' ||\n      blockElements.includes(node.name))\n  );\n}\n\nexport function isTextNodeStartingWithLinebreak(\n  node: TextNode,\n  nrLines = 1\n): node is TextNode {\n  return startsWithLinebreak(getUnencodedText(node), nrLines);\n  // return node.type === 'Text' && startsWithLinebreak(getUnencodedText(node), nrLines);\n}\n\nexport function startsWithLinebreak(text: string, nrLines = 1): boolean {\n  return new RegExp(`^([\\\\t\\\\f\\\\r ]*\\\\n){${nrLines}}`).test(text);\n}\n\n// export function isTextNodeEndingWithLinebreak(node: TextNode, nrLines: number = 1) {\n//   return node.type === 'text' && endsWithLinebreak(getUnencodedText(node), nrLines);\n// }\n\nexport function endsWithLinebreak(text: string, nrLines = 1): boolean {\n  return new RegExp(`(\\\\n[\\\\t\\\\f\\\\r ]*){${nrLines}}$`).test(text);\n}\n\nexport function isTextNodeStartingWithWhitespace(node: Node): node is TextNode {\n  return node.type === 'text' && /^\\s/.test(getUnencodedText(node));\n}\n\nexport function isTextNodeEndingWithWhitespace(node: Node): node is TextNode {\n  return node.type === 'text' && /\\s$/.test(getUnencodedText(node));\n}\n\nexport function forceIntoExpression(statement: string): string {\n  // note the trailing newline: if the statement ends in a // comment,\n  // we can't add the closing bracket right afterwards\n  return `(${statement}\\n)`;\n}\n\n/**\n * Check if given node's starg tag should hug its first child. This is the case for inline elements when there's\n * no whitespace between the `>` and the first child.\n */\nexport function shouldHugStart(node: anyNode, opts: ParserOptions): boolean {\n  if (isBlockElement(node, opts)) {\n    return false;\n  }\n\n  if (!isNodeWithChildren(node)) {\n    return false;\n  }\n\n  const children = node.children;\n  if (children.length === 0) {\n    return true;\n  }\n\n  const firstChild = children[0];\n  return !isTextNodeStartingWithWhitespace(firstChild);\n}\n\n/**\n * Check if given node's end tag should hug its last child. This is the case for inline elements when there's\n * no whitespace between the last child and the `</`.\n */\nexport function shouldHugEnd(node: anyNode, opts: ParserOptions): boolean {\n  if (isBlockElement(node, opts)) {\n    return false;\n  }\n\n  if (!isNodeWithChildren(node)) {\n    return false;\n  }\n\n  const children = node.children;\n  if (children.length === 0) {\n    return true;\n  }\n\n  return false;\n\n  // TODO: WIP\n  // const lastChild = children[children.length - 1];\n  // return !isTextNodeEndingWithWhitespace(lastChild);\n}\n\n/**\n * Returns true if the softline between `</tagName` and `>` can be omitted.\n */\nexport function canOmitSoftlineBeforeClosingTag(\n  path: AstPath,\n  opts: ParserOptions\n): boolean {\n  return isLastChildWithinParentBlockElement(path, opts);\n  // return !hugsStartOfNextNode(node, options) || isLastChildWithinParentBlockElement(path, options);\n  // return !options.svelteBracketNewLine && (!hugsStartOfNextNode(node, options) || isLastChildWithinParentBlockElement(path, options));\n}\n\n/**\n * Return true if given node does not hug the next node, meaning there's whitespace\n * or the end of the doc afterwards.\n */\n// function hugsStartOfNextNode(node: anyNode, opts: ParserOptions): boolean {\n//   if (node.end === opts.originalText.length) {\n//     // end of document\n//     return false;\n//   }\n\n//   return !opts.originalText.substring(node.end).match(/^\\s/);\n// }\n\nfunction getChildren(node: anyNode): Node[] {\n  return isNodeWithChildren(node) ? node.children : [];\n}\n\nfunction isLastChildWithinParentBlockElement(\n  path: AstPath,\n  opts: ParserOptions\n): boolean {\n  const parent = path.getParentNode();\n  if (!parent || !isBlockElement(parent, opts)) {\n    return false;\n  }\n\n  const children = getChildren(parent);\n  const lastChild = children[children.length - 1];\n  return lastChild === path.getNode();\n}\n\nexport function trimTextNodeLeft(node: TextNode): void {\n  node.value = node.value && node.value.trimStart();\n}\n\nexport function trimTextNodeRight(node: TextNode): void {\n  node.value = node.value && node.value.trimEnd();\n}\n\n// export function findLastIndex<T>(isMatch: (item: T, idx: number) => boolean, items: T[]) {\n//   for (let i = items.length - 1; i >= 0; i--) {\n//     if (isMatch(items[i], i)) {\n//       return i;\n//     }\n//   }\n\n//   return -1;\n// }\n\n/**\n * Remove all leading whitespace up until the first non-empty text node,\n * and all trailing whitepsace from the last non-empty text node onwards.\n */\n// export function trimChildren(children: anyNode[]) {\n//   // export function trimChildren(children: anyNode[], path: AstPath<anyNode>) {\n//   let firstNonEmptyNode = children.findIndex((n) => !isEmptyTextNode(n));\n//   // let firstNonEmptyNode = children.findIndex((n) => !isEmptyTextNode(n) && !doesEmbedStartAfterNode(n, path));\n//   firstNonEmptyNode = firstNonEmptyNode === -1 ? children.length - 1 : firstNonEmptyNode;\n\n//   let lastNonEmptyNode = findLastIndex((n, idx) => {\n//     // Last node is ok to end at the start of an embedded region,\n//     // if it's not a comment (which should stick to the region)\n//     return !isEmptyTextNode(n);\n//     // return !isEmptyTextNode(n) && ((idx === children.length - 1 && n.type !== 'Comment') || !doesEmbedStartAfterNode(n, path));\n//   }, children);\n//   lastNonEmptyNode = lastNonEmptyNode === -1 ? 0 : lastNonEmptyNode;\n\n//   for (let i = 0; i <= firstNonEmptyNode; i++) {\n//     const n = children[i];\n//     if (isTextNode(n)) {\n//       trimTextNodeLeft(n);\n//     }\n//   }\n\n//   for (let i = children.length - 1; i >= lastNonEmptyNode; i--) {\n//     const n = children[i];\n//     if (isTextNode(n)) {\n//       trimTextNodeRight(n);\n//     }\n//   }\n// }\n\n/**\n * Returns siblings, that is, the children of the parent.\n */\n// export function getSiblings(path: AstPath): anyNode[] {\n//   let parent = path.getParentNode();\n//   if (!parent) return [];\n\n//   if (isRootNode(parent)) {\n//     parent = parent.html;\n//   }\n\n//   return getChildren(parent);\n// }\n\n/**\n * Did there use to be any embedded object (that has been snipped out of the AST to be moved)\n * at the specified position?\n */\n// function doesEmbedStartAfterNode(node: anyNode, path: AstPath<anyNode>, siblings = getSiblings(path)): boolean {\n//   // If node is not at the top level of html, an embed cannot start after it,\n//   // because embeds are only at the top level\n//   if (!isNodeTopLevelHTML(node, path)) {\n//     return false;\n//   }\n\n//   const position = node.end;\n//   const root = path.stack[0];\n\n//   const embeds = [root.module, root.html, root.css];\n\n//   const nextNode = siblings[siblings.indexOf(node) + 1];\n//   return embeds.find((n) => n && n.start >= position && (!nextNode || n.end <= nextNode.start));\n// }\n\n// function isNodeTopLevelHTML(node: anyNode, path: AstPath<anyNode>) {\n//   const root = path.stack[0];\n//   return !!root.html && !!root.html.children && root.html.children.includes(node);\n// }\n\n/**\n * Check if doc is a hardline.\n * We can't just rely on a simple equality check because the doc could be created with another\n * runtime version of prettier than what we import, making a reference check fail.\n */\n\n// function isHardline(docToCheck: Doc): boolean {\n//   return docToCheck === doc.builders.hardline || deepEqual(docToCheck, doc.builders.hardline);\n// }\n\n/**\n * Simple deep equal function which suits our needs. Only works properly on POJOs without cyclic deps.\n */\n// function deepEqual(x: any, y: any): boolean {\n//   if (x === y) {\n//     return true;\n//   } else if (typeof x == 'object' && x != null && typeof y == 'object' && y != null) {\n//     if (Object.keys(x).length != Object.keys(y).length) return false;\n\n//     for (var prop in x) {\n//       if (Object.prototype.hasOwnProperty.call(y, prop)) {\n//         if (!deepEqual(x[prop], y[prop])) return false;\n//       } else {\n//         return false;\n//       }\n//     }\n\n//     return true;\n//   } else {\n//     return false;\n//   }\n// }\n\n// export function isLine(docToCheck: Doc): boolean {\n//   return (\n//     isHardline(docToCheck) ||\n//     (typeof docToCheck === 'object' && isDocCommand(docToCheck) && docToCheck.type === 'line') ||\n//     (typeof docToCheck === 'object' && isDocCommand(docToCheck) && docToCheck.type === 'concat' && docToCheck.parts.every(isLine))\n//   );\n// }\n\n/**\n * Check if the doc is empty, i.e. consists of nothing more than empty strings (possibly nested).\n */\n// export function isEmptyDoc(doc: Doc): boolean {\n//   if (typeof doc === 'string') {\n//     return doc.length === 0;\n//   }\n\n//   // if (doc.type === 'line') {\n//   //   return !doc.keepIfLonely;\n//   // }\n\n//   // Since Prettier 2.3.0, concats are represented as flat arrays\n//   if (Array.isArray(doc)) {\n//     return doc.length === 0;\n//   }\n\n//   // const { contents } = doc;\n\n//   // if (contents) {\n//   //   return isEmptyDoc(contents);\n//   // }\n\n//   // const { parts } = doc;\n\n//   // if (parts) {\n//   //   return isEmptyGroup(parts);\n//   // }\n\n//   return false;\n// }\n\n// function isEmptyGroup(group: any) {\n//   return !group.find((doc: any) => !isEmptyDoc(doc));\n// }\n\n/**\n * Trims both leading and trailing nodes matching `isWhitespace` independent of nesting level\n * (though all trimmed adjacent nodes need to be a the same level). Modifies the `docs` array.\n */\n// export function trim(docs: Doc[], isWhitespace: (doc: Doc) => boolean): Doc[] {\n//   trimLeft(docs, isWhitespace);\n//   trimRight(docs, isWhitespace);\n\n//   return docs;\n// }\n\n/**\n * Trims the leading nodes matching `isWhitespace` independent of nesting level (though all nodes need to be a the same level).\n * If there are empty docs before the first whitespace, they are removed, too.\n */\n// function trimLeft(group: Doc[], isWhitespace: (doc: Doc) => boolean): void {\n//   let firstNonWhitespace = group.findIndex((doc) => !isEmptyDoc(doc) && !isWhitespace(doc));\n\n//   if (firstNonWhitespace < 0 && group.length) {\n//     firstNonWhitespace = group.length;\n//   }\n\n//   if (firstNonWhitespace > 0) {\n//     const removed = group.splice(0, firstNonWhitespace);\n//     if (removed.every(isEmptyDoc)) {\n//       return trimLeft(group, isWhitespace);\n//     }\n//   } else {\n//     const parts = getParts(group[0]);\n\n//     if (parts) {\n//       return trimLeft(parts, isWhitespace);\n//     }\n//   }\n// }\n\n/**\n * Trims the trailing nodes matching `isWhitespace` independent of nesting level (though all nodes need to be a the same level).\n * If there are empty docs after the last whitespace, they are removed, too.\n */\n// function trimRight(group: Doc[], isWhitespace: (doc: Doc) => boolean): void {\n//   let lastNonWhitespace = group.length ? findLastIndex((doc: any) => !isEmptyDoc(doc) && !isWhitespace(doc), group) : 0;\n\n//   if (lastNonWhitespace < group.length - 1) {\n//     const removed = group.splice(lastNonWhitespace + 1);\n//     if (removed.every(isEmptyDoc)) {\n//       return trimRight(group, isWhitespace);\n//     }\n//   } else {\n//     const parts = getParts(group[group.length - 1]);\n\n//     if (parts) {\n//       return trimRight(parts, isWhitespace);\n//     }\n//   }\n// }\n\n// function getParts(doc: Doc): Doc[] | undefined {\n//   if (typeof doc === 'object') {\n//     // Since Prettier 2.3.0, concats are represented as flat arrays\n//     if (Array.isArray(doc)) {\n//       return doc;\n//     }\n//     if (doc.type === 'fill' || doc.type === 'concat') {\n//       return doc.parts;\n//     }\n//     if (doc.type === 'group') {\n//       return getParts(doc.contents);\n//     }\n//   }\n// }\n\n// export const isObjEmpty = (obj: object): boolean => {\n//   for (let i in obj) return false;\n//   return true;\n// };\n\n/** Shallowly attach comments to children */\n// export function attachCommentsHTML(node: anyNode): void {\n//   if (!isNodeWithChildren(node) || !node.children.some(({ type }) => type === 'Comment')) return;\n\n//   const nodesToRemove = [];\n\n//   // note: the .length - 1 is because we don’t need to read the last node\n//   for (let n = 0; n < node.children.length - 1; n++) {\n//     if (!node.children[n]) continue;\n\n//     // attach comment to the next non-whitespace node\n//     if (node.children[n].type === 'Comment') {\n//       let next = n + 1;\n//       while (isEmptyTextNode(node.children[next])) {\n//         nodesToRemove.push(next); // if arbitrary whitespace between comment and node, remove\n//         next++; // skip to the next non-whitespace node\n//       }\n//       const commentNode = node.children[next];\n//       if (commentNode) {\n//         const comment = node.children[n];\n//         util.addLeadingComment(commentNode, comment);\n//       }\n//     }\n//   }\n\n//   // remove arbitrary whitespace nodes\n//   nodesToRemove.reverse(); // start at back so we aren’t changing indices\n//   nodesToRemove.forEach((index) => {\n//     node.children.splice(index, 1);\n//   });\n// }\n\n/** dedent string & return tabSize (the last part is what we need) */\nexport function manualDedent(input: string): {\n  tabSize: number;\n  char: string;\n  result: string;\n} {\n  let minTabSize = Infinity;\n  let result = input;\n  // 1. normalize\n  result = result.replace(/\\r\\n/g, '\\n');\n\n  // 2. count tabSize\n  let char = '';\n  for (const line of result.split('\\n')) {\n    if (!line) continue;\n    // if any line begins with a non-whitespace char, minTabSize is 0\n    if (line[0] && /^[^\\s]/.test(line[0])) {\n      minTabSize = 0;\n      break;\n    }\n    const match = line.match(/^(\\s+)\\S+/); // \\S ensures we don’t count lines of pure whitespace\n    if (match) {\n      if (match[1] && !char) char = match[1][0];\n      if (match[1].length < minTabSize) minTabSize = match[1].length;\n    }\n  }\n\n  // 3. reformat string\n  if (minTabSize > 0 && Number.isFinite(minTabSize)) {\n    result = result.replace(\n      new RegExp(`^${new Array(minTabSize + 1).join(char)}`, 'gm'),\n      ''\n    );\n  }\n\n  return {\n    tabSize: minTabSize === Infinity ? 0 : minTabSize,\n    char,\n    result,\n  };\n}\n\n/** re-indent string by chars */\n// export function indent(input: string, char: string = ' '): string {\n//   return input.replace(/^(.)/gm, `${char}$1`);\n// }\n\n/** scan code for Markdown name(s) */\nexport function getMarkdownName(script: string): Set<string> {\n  // default import: could be named anything\n  let defaultMatch;\n  while (\n    (defaultMatch =\n      /import\\s+([^\\s]+)\\s+from\\s+['|\"|`]astro\\/components\\/Markdown\\.astro/g.exec(\n        script\n      ))\n  ) {\n    if (defaultMatch[1]) return new Set([defaultMatch[1].trim()]);\n  }\n\n  // named component: must have \"Markdown\" in specifier, but can be renamed via \"as\"\n  let namedMatch;\n  while (\n    (namedMatch =\n      /import\\s+\\{\\s*([^}]+)\\}\\s+from\\s+['|\"|`]astro\\/components/g.exec(script))\n  ) {\n    if (namedMatch[1] && !namedMatch[1].includes('Markdown')) continue;\n    // if \"Markdown\" was imported, find out whether or not it was renamed\n    const rawImports = namedMatch[1]\n      .trim()\n      .replace(/^\\{/, '')\n      .replace(/\\}$/, '')\n      .trim();\n    let importName = 'Markdown';\n    for (const spec of rawImports.split(',')) {\n      const [original, renamed] = spec.split(' as ').map((s) => s.trim());\n      if (original !== 'Markdown') continue;\n      importName = renamed || original;\n      break;\n    }\n    return new Set([importName]);\n  }\n  return new Set(['Markdown']);\n}\n\n// TODO: USE THE COMPILER\n/** True if the node is of type text */\nexport function isTextNode(node: anyNode): node is TextNode {\n  return node.type === 'text';\n}\n\n// export function isMustacheNode(node: anyNode): node is MustacheTagNode {\n//   return node.type === 'MustacheTag';\n// }\n\n// export function isDocCommand(doc: Doc): doc is doc.builders.DocCommand {\n//   if (typeof doc === 'string') return false;\n//   if (Array.isArray(doc)) return false;\n//   return true;\n// }\n\nexport function isInsideQuotedAttribute(path: AstPath): boolean {\n  const stack = path.stack as anyNode[];\n  return stack.some(\n    (node) => node.type === 'attribute' && !isLoneMustacheTag(node)\n  );\n}\n\n/**\n * Currently, the compiler has a bug that duplicates text nodes when no\n *  TagLikeNode elements are present.\n */\nexport function removeDuplicates(root: RootNode) {\n  root.children = root.children.filter((node, i, rootChildren) => {\n    if (node.type !== 'text') return true;\n    // https://stackoverflow.com/questions/2218999/how-to-remove-all-duplicates-from-an-array-of-objects\n    return (\n      i ===\n      rootChildren.findIndex((t) => {\n        if (t.position && node.position) {\n          return (\n            node.type === 'text' &&\n            t.position.start.offset === node.position.start.offset &&\n            t.position.start.line === node.position.start.line &&\n            t.position.start.column === node.position.start.column\n          );\n        }\n      })\n    );\n  });\n}\n\n/** True if the node is TagLikeNode:\n *\n * ElementNode | ComponentNode | CustomElementNode | FragmentNode */\nexport function isTagLikeNode(node: anyNode): node is TagLikeNode {\n  return (\n    node.type === 'element' ||\n    node.type === 'component' ||\n    node.type === 'custom-element' ||\n    node.type === 'fragment'\n  );\n}\n\n/**\n * Returns siblings, that is, the children of the parent.\n */\nexport function getSiblings(path: AstPath): anyNode[] {\n  const parent = path.getParentNode();\n  if (!parent) return [];\n\n  return getChildren(parent);\n}\n\nexport function getNextNode(path: AstPath): anyNode | null {\n  const node = path.getNode();\n  if (node) {\n    const siblings = getSiblings(path);\n    if (node.position?.start === siblings[siblings.length - 1].position?.start)\n      return null;\n    for (let i = 0; i < siblings.length; i++) {\n      const sibling = siblings[i];\n      if (\n        sibling.position?.start === node.position?.start &&\n        i !== siblings.length - 1\n      ) {\n        return siblings[i + 1];\n      }\n    }\n  }\n  return null;\n}\n","import {\n  AstPath as AstP,\n  BuiltInParsers,\n  Doc,\n  ParserOptions as ParserOpts,\n  Printer,\n} from 'prettier';\nimport _doc from 'prettier/doc';\nconst {\n  builders: {\n    breakParent,\n    dedent,\n    fill,\n    group,\n    hardline,\n    indent,\n    join,\n    line,\n    literalline,\n    softline,\n  },\n  utils: { removeLines, stripTrailingHardline },\n} = _doc;\nimport { SassFormatter, SassFormatterConfig } from 'sass-formatter';\n\nimport { parseSortOrder } from './options';\n\nimport {\n  RootNode,\n  Node,\n  AttributeNode,\n  CommentNode,\n  NodeWithText,\n  selfClosingTags,\n  TextNode,\n  anyNode,\n} from './nodes';\n\ntype ParserOptions = ParserOpts<anyNode>;\ntype AstPath = AstP<anyNode>;\n\nimport {\n  // attachCommentsHTML,\n  canOmitSoftlineBeforeClosingTag,\n  manualDedent,\n  endsWithLinebreak,\n  forceIntoExpression,\n  formattableAttributes,\n  getMarkdownName,\n  getText,\n  getUnencodedText,\n  isRootNode,\n  // isDocCommand,\n  // isEmptyDoc,\n  isEmptyTextNode,\n  isInlineElement,\n  isInsideQuotedAttribute,\n  // isLine,\n  isLoneMustacheTag,\n  // isNodeWithChildren,\n  isOrCanBeConvertedToShorthand,\n  isPreTagContent,\n  isShorthandAndMustBeConvertedToBinaryExpression,\n  isTextNode,\n  isTextNodeEndingWithWhitespace,\n  isTextNodeStartingWithLinebreak,\n  isTextNodeStartingWithWhitespace,\n  printRaw,\n  // replaceEndOfLineWith,\n  shouldHugEnd,\n  shouldHugStart,\n  startsWithLinebreak,\n  // trim,\n  // trimChildren,\n  trimTextNodeLeft,\n  trimTextNodeRight,\n  removeDuplicates,\n  getNextNode,\n  isTagLikeNode,\n} from './utils';\n\n// function printTopLevelParts(node: RootNode, path: AstPath, opts: ParserOptions, print: printFn): Doc {\n//   let docs = [];\n\n//   const normalize = (doc: Doc) => [stripTrailingHardline(doc), hardline];\n\n//   // frontmatter always comes first\n//   if (node.module) {\n//     const subDoc = normalize(path.call(print, 'module'));\n//     docs.push(subDoc);\n//   }\n\n//   // markup and styles follow, whichever the user prefers (default: markup, styles)\n//   for (const section of parseSortOrder(opts.astroSortOrder)) {\n//     switch (section) {\n//       case 'markup': {\n//         const subDoc = path.call(print, 'html');\n//         if (!isEmptyDoc(subDoc)) docs.push(normalize(subDoc));\n//         break;\n//       }\n//       case 'styles': {\n//         const subDoc = path.call(print, 'css');\n//         if (!isEmptyDoc(subDoc)) docs.push(normalize(subDoc));\n//         break;\n//       }\n//     }\n//   }\n\n//   return join(softline, docs);\n// }\n\n// function printAttributeNodeValue(path: AstPath, print: printFn, quotes: boolean, node: AttributeNode): Doc[] | _doc.builders.Indent {\n//   const valueDocs = path.map((childPath) => childPath.call(print), 'value');\n\n//   if (!quotes || !formattableAttributes.includes(node.name)) {\n//     return valueDocs;\n//   } else {\n//     return indent(group(trim(valueDocs, isLine)));\n//   }\n// }\n\n// TODO: USE ASTPATH GENERIC\n// function printJS(path: AstP, print: printFn, name: string, { forceSingleQuote, forceSingleLine }: { forceSingleQuote: boolean; forceSingleLine: boolean }) {\n//   path.getValue()[name].isJS = true;\n//   path.getValue()[name].forceSingleQuote = forceSingleQuote;\n//   path.getValue()[name].forceSingleLine = forceSingleLine;\n//   return path.call(print, name);\n// }\n\n// TODO: MAYBE USE THIS TO HANDLE COMMENTS\nfunction printComment(commentPath: AstPath, options: ParserOptions): Doc {\n  // note(drew): this isn’t doing anything currently, but Prettier requires it anyway\n  // @ts-ignore\n  return commentPath;\n}\n\nexport type printFn = (path: AstPath) => Doc;\n\n// eslint-disable-next-line @typescript-eslint/no-shadow\nfunction print(path: AstPath, opts: ParserOptions, print: printFn): Doc {\n  const node = path.getValue();\n  // const isMarkdownSubDoc = opts.parentParser === 'markdown'; // is this a code block within .md?\n\n  // 1. handle special node types\n  if (!node) {\n    return '';\n  }\n\n  if (typeof node === 'string') {\n    return node;\n  }\n\n  // if (Array.isArray(node)) {\n  //   return path.map((childPath) => childPath.call(print));\n  // }\n\n  // if (isASTNode(node)) {\n  //   return printTopLevelParts(node, path, opts, print);\n  // }\n\n  // 2. attach comments shallowly to children, if any (https://prettier.io/docs/en/plugins.html#manually-attaching-a-comment)\n  // if (!isPreTagContent(path) && !isMarkdownSubDoc && node.type === 'Fragment') {\n  //   attachCommentsHTML(node);\n  // }\n\n  // 3. handle printing\n  switch (node.type) {\n    case 'root': {\n      removeDuplicates(node);\n      return [stripTrailingHardline(path.map(print, 'children')), hardline];\n    }\n\n    // case 'Fragment': {\n    //   const text = getText(node, opts);\n    //   if (text.length === 0) {\n    //     return '';\n    //   }\n\n    //   if (!isNodeWithChildren(node) || node.children.every(isEmptyTextNode)) return '';\n\n    //   if (!isPreTagContent(path)) {\n    //     trimChildren(node.children);\n    //     const output = trim(\n    //       [path.map(print, 'children')],\n    //       (n) =>\n    //         isLine(n) ||\n    //         (typeof n === 'string' && n.trim() === '') ||\n    //         // Because printChildren may append this at the end and\n    //         // may hide other lines before it\n    //         n === breakParent\n    //     );\n    //     if (output.every((doc) => isEmptyDoc(doc))) {\n    //       return '';\n    //     }\n    //     return group([...output, hardline]);\n    //   } else {\n    //     return group(path.map(print, 'children'));\n    //   }\n    // }\n    case 'text': {\n      const rawText = getUnencodedText(node);\n\n      // TODO: TEST PRE TAGS\n      // if (isPreTagContent(path)) {\n      //   if (path.getParentNode()?.type === 'Attribute') {\n      //     // Direct child of attribute value -> add literallines at end of lines\n      //     // so that other things don't break in unexpected places\n      //     return replaceEndOfLineWith(rawText, literalline);\n      //   }\n      //   return rawText;\n      // }\n\n      if (isEmptyTextNode(node)) {\n        const hasWhiteSpace =\n          rawText.trim().length < getUnencodedText(node).length;\n        const hasOneOrMoreNewlines = /\\n/.test(getUnencodedText(node));\n        const hasTwoOrMoreNewlines = /\\n\\r?\\s*\\n\\r?/.test(\n          getUnencodedText(node)\n        );\n        if (hasTwoOrMoreNewlines) {\n          return [hardline, hardline];\n        }\n        if (hasOneOrMoreNewlines) {\n          return hardline;\n        }\n        if (hasWhiteSpace) {\n          return line;\n        }\n        return '';\n      }\n\n      /**\n       * For non-empty text nodes each sequence of non-whitespace characters (effectively,\n       * each \"word\") is joined by a single `line`, which will be rendered as a single space\n       * until this node's current line is out of room, at which `fill` will break at the\n       * most convenient instance of `line`.\n       */\n      return fill(splitTextToDocs(node));\n    }\n\n    // case 'InlineComponent':\n    // case 'Slot':\n    case 'component':\n    case 'fragment':\n    case 'element': {\n      // const isEmpty = node.children?.every((child) => isEmptyTextNode(child));\n      let isEmpty: boolean;\n      if (!node.children) {\n        isEmpty = true;\n      } else {\n        isEmpty = node.children.every((child) => isEmptyTextNode(child));\n      }\n      const isSelfClosingTag =\n        isEmpty &&\n        (node.type !== 'element' || selfClosingTags.indexOf(node.name) !== -1);\n\n      const attributes = path.map(print, 'attributes');\n      if (isSelfClosingTag) {\n        return group(['<', node.name, indent(group(attributes)), line, `/>`]);\n        // return group(['<', node.name, indent(group([...attributes, opts.jsxBracketNewLine ? dedent(line) : ''])), ...[opts.jsxBracketNewLine ? '' : ' ', `/>`]]);\n      }\n\n      if (node.children) {\n        const children = node.children;\n        const firstChild = children[0];\n        const lastChild = children[children.length - 1];\n\n        // No hugging of content means it's either a block element and/or there's whitespace at the start/end\n        let noHugSeparatorStart:\n          | _doc.builders.Concat\n          | _doc.builders.Line\n          | _doc.builders.Softline\n          | string = softline;\n        let noHugSeparatorEnd:\n          | _doc.builders.Concat\n          | _doc.builders.Line\n          | _doc.builders.Softline\n          | string = softline;\n        const hugStart = shouldHugStart(node, opts);\n        const hugEnd = shouldHugEnd(node, opts);\n\n        let body;\n\n        if (isEmpty) {\n          body =\n            isInlineElement(path, opts, node) &&\n            node.children.length &&\n            isTextNodeStartingWithWhitespace(node.children[0]) &&\n            !isPreTagContent(path)\n              ? () => line\n              : // () => (opts.jsxBracketNewLine ? '' : softline);\n                () => softline;\n        } else if (isPreTagContent(path)) {\n          body = () => printRaw(node);\n        } else if (\n          isInlineElement(path, opts, node) &&\n          !isPreTagContent(path)\n        ) {\n          body = () => path.map(print, 'children');\n        } else {\n          body = () => path.map(print, 'children');\n        }\n\n        const openingTag = [\n          '<',\n          node.name,\n          indent(\n            group([\n              ...attributes,\n              hugStart\n                ? ''\n                : !isPreTagContent(path) && !opts.bracketSameLine\n                ? dedent(softline)\n                : '',\n            ])\n          ),\n        ];\n        // const openingTag = ['<', node.name, indent(group([...attributes, hugStart ? '' : opts.jsxBracketNewLine && !isPreTagContent(path) ? dedent(softline) : '']))];\n\n        if (hugStart && hugEnd) {\n          const huggedContent = [\n            softline,\n            group(['>', body(), `</${node.name}`]),\n          ];\n\n          const omitSoftlineBeforeClosingTag =\n            isEmpty || canOmitSoftlineBeforeClosingTag(path, opts);\n          // const omitSoftlineBeforeClosingTag = (isEmpty && opts.jsxBracketNewLine) || canOmitSoftlineBeforeClosingTag(node, path, opts);\n          return group([\n            ...openingTag,\n            isEmpty ? group(huggedContent) : group(indent(huggedContent)),\n            omitSoftlineBeforeClosingTag ? '' : softline,\n            '>',\n          ]);\n        }\n\n        if (isPreTagContent(path)) {\n          noHugSeparatorStart = '';\n          noHugSeparatorEnd = '';\n        } else {\n          let didSetEndSeparator = false;\n\n          if (!hugStart && firstChild && isTextNode(firstChild)) {\n            if (\n              isTextNodeStartingWithLinebreak(firstChild) &&\n              firstChild !== lastChild &&\n              (!isInlineElement(path, opts, node) ||\n                isTextNodeEndingWithWhitespace(lastChild))\n            ) {\n              noHugSeparatorStart = hardline;\n              noHugSeparatorEnd = hardline;\n              didSetEndSeparator = true;\n            } else if (isInlineElement(path, opts, node)) {\n              noHugSeparatorStart = line;\n            }\n            trimTextNodeLeft(firstChild);\n          }\n          if (!hugEnd && lastChild && isTextNode(lastChild)) {\n            if (isInlineElement(path, opts, node) && !didSetEndSeparator) {\n              noHugSeparatorEnd = softline;\n            }\n            trimTextNodeRight(lastChild);\n          }\n        }\n\n        if (hugStart) {\n          return group([\n            ...openingTag,\n            indent([softline, group(['>', body()])]),\n            noHugSeparatorEnd,\n            `</${node.name}>`,\n          ]);\n        }\n\n        if (hugEnd) {\n          return group([\n            ...openingTag,\n            '>',\n            indent([noHugSeparatorStart, group([body(), `</${node.name}`])]),\n            canOmitSoftlineBeforeClosingTag(path, opts) ? '' : softline,\n            '>',\n          ]);\n        }\n\n        if (isEmpty) {\n          return group([...openingTag, '>', body(), `</${node.name}>`]);\n        }\n\n        return group([\n          ...openingTag,\n          '>',\n          indent([noHugSeparatorStart, body()]),\n          noHugSeparatorEnd,\n          `</${node.name}>`,\n        ]);\n      }\n      // TODO: WIP\n      return '';\n    }\n    // case 'AttributeShorthand': {\n    //   return node.expression.name;\n    // }\n    case 'attribute': {\n      const name = node.name.trim();\n      const quote = opts.singleQuote ? \"'\" : '\"';\n      switch (node.kind) {\n        case 'empty':\n          return [line, name];\n        case 'expression':\n          // HANDLED IN EMBED FUNCION\n          return '';\n        case 'quoted':\n          return [line, name, '=', quote, node.value, quote];\n        case 'shorthand':\n          return [line, '{', name, '}'];\n        case 'spread':\n          return [line, '{...', name, '}'];\n        case 'template-literal':\n          return [line, name, '=', '`', node.value, '`'];\n        default:\n          break;\n      }\n      return '';\n    }\n\n    case 'doctype': {\n      // https://www.w3.org/wiki/Doctypes_and_markup_styles\n      return ['<!DOCTYPE html>', hardline];\n    }\n    // case 'Expression':\n    //   // missing test ?\n    //   return [];\n    // case 'MustacheTag':\n    //   return [\n    //     '{',\n    //     printJS(path, print, 'expression', {\n    //       forceSingleLine: isInsideQuotedAttribute(path),\n    //       forceSingleQuote: opts.jsxSingleQuote,\n    //     }),\n    //     '}',\n    //   ];\n    // case 'Spread':\n    //   return [\n    //     line,\n    //     '{...',\n    //     printJS(path, print, 'expression', {\n    //       forceSingleQuote: true,\n    //       forceSingleLine: false,\n    //     }),\n    //     '}',\n    //   ];\n    case 'comment':\n      const nextNode = getNextNode(path);\n      let trailingLine: _doc.builders.Concat | string = '';\n      if (nextNode && isTagLikeNode(nextNode)) {\n        trailingLine = hardline;\n      }\n      return ['<!--', getUnencodedText(node), '-->', trailingLine];\n    // case 'CodeSpan':\n    //   return getUnencodedText(node);\n    // case 'CodeFence': {\n    //   console.debug(node);\n    //   // const lang = node.metadata.slice(3);\n    //   return [node.metadata, hardline, /** somehow call textToDoc(lang),  */ node.data, hardline, '```', hardline];\n\n    //   // We should use `node.metadata` to select a parser to embed with... something like return [node.metadata, hardline textToDoc(node.getMetadataLanguage()), hardline, `\\`\\`\\``];\n    // }\n    default: {\n      throw new Error(`Unhandled node type \"${node.type}\"!`);\n    }\n  }\n}\n\n/**\n * Split the text into words separated by whitespace. Replace the whitespaces by lines,\n * collapsing multiple whitespaces into a single line.\n *\n * If the text starts or ends with multiple newlines, two of those should be kept.\n */\nfunction splitTextToDocs(node: NodeWithText): Doc[] {\n  const text = getUnencodedText(node);\n\n  const textLines = text.split(/[\\t\\n\\f\\r ]+/);\n\n  let docs = join(line, textLines).parts.filter((s) => s !== '');\n\n  if (startsWithLinebreak(text)) {\n    docs[0] = hardline;\n  }\n  if (startsWithLinebreak(text, 2)) {\n    docs = [hardline, ...docs];\n  }\n\n  if (endsWithLinebreak(text)) {\n    docs[docs.length - 1] = hardline;\n  }\n  if (endsWithLinebreak(text, 2)) {\n    docs = [...docs, hardline];\n  }\n\n  return docs;\n}\n\nfunction expressionParser(\n  text: string,\n  parsers: BuiltInParsers,\n  opts: ParserOptions\n) {\n  const ast = parsers.babel(text, opts);\n  // const ast = parsers.babel(text, parsers, opts);\n\n  return { ...ast, program: ast.program.body[0].expression };\n}\n\nlet markdownComponentName = new Set();\n\nfunction embed(\n  path: AstPath,\n  // eslint-disable-next-line @typescript-eslint/no-shadow\n  print: printFn,\n  textToDoc: (text: string, options: object) => Doc,\n  opts: ParserOptions\n) {\n  // TODO: ADD TYPES OR FIND ANOTHER WAY TO ACHIVE THIS\n  // @ts-ignore\n  if (!opts.__astro) opts.__astro = {};\n\n  const node = path.getValue();\n\n  if (!node) return null;\n\n  if (node.type === 'expression') {\n    const textContent = printRaw(node);\n\n    let content: Doc;\n\n    content = textToDoc(forceIntoExpression(textContent), {\n      ...opts,\n      parser: expressionParser,\n      semi: false,\n    });\n    content = stripTrailingHardline(content);\n\n    // if (node.children[0].value) {\n    //   content = textToDoc(forceIntoExpression(textContent), { parser: expressionParser });\n    // } else {\n    //   content = textToDoc(forceIntoExpression(node.children[0].value), { parser: expressionParser });\n    // }\n    return [\n      '{',\n      // printJS(path, print, 'expression', {\n      //   forceSingleLine: isInsideQuotedAttribute(path),\n      //   forceSingleQuote: opts.jsxSingleQuote,\n      // }),\n      content,\n      '}',\n    ];\n  }\n\n  // ATTRIBUTE WITH EXPRESSION AS VALUE\n  if (node.type === 'attribute' && node.kind === 'expression') {\n    const value = node.value.trim();\n    const name = node.name.trim();\n    let attrNodeValue = textToDoc(forceIntoExpression(value), {\n      ...opts,\n      parser: expressionParser,\n      semi: false,\n    });\n    attrNodeValue = stripTrailingHardline(attrNodeValue);\n    // if (Array.isArray(attrNodeValue) && attrNodeValue[0] === ';') {\n    //   attrNodeValue = attrNodeValue.slice(1);\n    // }\n    if (name === value && opts.astroAllowShorthand) {\n      return [line, '{', attrNodeValue, '}'];\n    }\n    return [line, name, '=', '{', attrNodeValue, '}'];\n  }\n\n  // TODO: ADD TYPES OR FIND ANOTHER WAY TO ACHIVE THIS\n  // @ts-ignore\n  // if (node.isJS) {\n  //   try {\n  //     const embeddedopts = {\n  //       parser: expressionParser,\n  //     };\n  //     // TODO: ADD TYPES OR FIND ANOTHER WAY TO ACHIVE THIS\n  //     // @ts-ignore\n  //     if (node.forceSingleQuote) {\n  //       // TODO: ADD TYPES OR FIND ANOTHER WAY TO ACHIVE THIS\n  //       // @ts-ignore\n  //       embeddedopts.singleQuote = true;\n  //     }\n\n  //     const docs = textToDoc(forceIntoExpression(getText(node, opts)), embeddedopts);\n  //     // TODO: ADD TYPES OR FIND ANOTHER WAY TO ACHIVE THIS\n  //     // @ts-ignore\n  //     return node.forceSingleLine ? removeLines(docs) : docs;\n  //   } catch (e) {\n  //     return getText(node, opts);\n  //   }\n  // }\n\n  if (node.type === 'frontmatter') {\n    markdownComponentName = getMarkdownName(node.value);\n    return [\n      group([\n        '---',\n        hardline,\n        textToDoc(node.value, { ...opts, parser: 'typescript' }),\n        '---',\n        hardline,\n      ]),\n      hardline,\n    ];\n  }\n\n  // format script element\n  if (node.type === 'element' && node.name === 'script') {\n    const scriptContent = printRaw(node);\n    let formatttedScript = textToDoc(scriptContent, {\n      ...opts,\n      parser: 'typescript',\n    });\n    formatttedScript = stripTrailingHardline(formatttedScript);\n\n    // print\n    const attributes = path.map(print, 'attributes');\n    const openingTag = group([\n      '<script',\n      indent(group(attributes)),\n      softline,\n      '>',\n    ]);\n    return [\n      openingTag,\n      indent([hardline, formatttedScript]),\n      hardline,\n      '</script>',\n    ];\n  }\n  // if (isTextNode(node)) {\n  //   const parent = path.getParentNode();\n\n  //   if (parent && parent.type === 'Element' && parent.name === 'script') {\n  //     const formatttedScript = textToDoc(node.data, { ...opts, parser: 'typescript' });\n  //     return stripTrailingHardline(formatttedScript);\n  //   }\n  // }\n\n  // format style element\n  if (node.type === 'element' && node.name === 'style') {\n    const styleTagContent = printRaw(node);\n\n    const supportedStyleLangValues = ['css', 'scss', 'sass'];\n    let parserLang = 'css';\n\n    if (node.attributes) {\n      const langAttribute = node.attributes.filter((x) => x.name === 'lang');\n      if (langAttribute.length) {\n        const styleLang = langAttribute[0].value.toLowerCase();\n        if (supportedStyleLangValues.includes(styleLang))\n          parserLang = styleLang;\n      }\n    }\n\n    switch (parserLang) {\n      case 'css':\n      case 'scss': {\n        // the css parser appends an extra indented hardline, which we want outside of the `indent()`,\n        // so we remove the last element of the array\n        let formattedStyles = textToDoc(styleTagContent, {\n          ...opts,\n          parser: parserLang,\n        });\n\n        formattedStyles = stripTrailingHardline(formattedStyles);\n\n        // print\n        const attributes = path.map(print, 'attributes');\n        const openingTag = group([\n          '<style',\n          indent(group(attributes)),\n          softline,\n          '>',\n        ]);\n        return [\n          openingTag,\n          indent([hardline, formattedStyles]),\n          hardline,\n          '</style>',\n        ];\n      }\n      case 'sass': {\n        const lineEnding =\n          opts.endOfLine.toUpperCase() === 'CRLF' ? 'CRLF' : 'LF';\n        const sassOptions: Partial<SassFormatterConfig> = {\n          tabSize: opts.tabWidth,\n          insertSpaces: !opts.useTabs,\n          lineEnding,\n        };\n\n        // dedent the .sass, otherwise SassFormatter gets indentation wrong\n        const { result: raw } = manualDedent(styleTagContent);\n\n        // format\n        const formattedSassIndented = SassFormatter.Format(\n          raw,\n          sassOptions\n        ).trim();\n\n        // print\n        const formattedSass = join(hardline, formattedSassIndented.split('\\n'));\n        const attributes = path.map(print, 'attributes');\n        const openingTag = group([\n          '<style',\n          indent(group(attributes)),\n          softline,\n          '>',\n        ]);\n        return [\n          openingTag,\n          indent(group([hardline, formattedSass])),\n          hardline,\n          '</style>',\n        ];\n      }\n    }\n  }\n\n  // MARKDOWN COMPONENT\n  if (node.type === 'component' && markdownComponentName.has(node.name)) {\n    let content = printRaw(node);\n\n    // dedent the content\n    content = content.replace(/\\r\\n/g, '\\n');\n    const contentArr = content.split('\\n').map((s) => s.trimStart());\n    content = contentArr.join('\\n');\n\n    // format\n    let formatttedMarkdown = textToDoc(content, {\n      ...opts,\n      parser: 'markdown',\n    });\n    formatttedMarkdown = stripTrailingHardline(formatttedMarkdown);\n\n    // return formatttedMarkdown;\n    const attributes = path.map(print, 'attributes');\n    const openingTag = group([\n      `<${node.name}`,\n      indent(group(attributes)),\n      softline,\n      '>',\n    ]);\n    return [\n      openingTag,\n      indent(group([hardline, formatttedMarkdown])),\n      hardline,\n      `</${node.name}>`,\n    ];\n  }\n\n  return null;\n}\n\nfunction hasPrettierIgnore(path: AstP<CommentNode>) {\n  // const node = path.getNode();\n\n  // if (!node || !Array.isArray(node.comments)) return false;\n\n  // const hasIgnore = node.comments.some(\n  //   (comment: any) => comment.data.includes('prettier-ignore') && !comment.data.includes('prettier-ignore-start') && !comment.data.includes('prettier-ignore-end')\n  // );\n  // return hasIgnore;\n  return false;\n}\n\nconst printer: Printer = {\n  print,\n  printComment,\n  embed,\n  hasPrettierIgnore,\n};\n\nexport default printer;\n","import { SupportOption } from 'prettier';\n\ndeclare module 'prettier' {\n  // eslint-disable-next-line @typescript-eslint/no-empty-interface\n  interface RequiredOptions extends PluginOptions {}\n}\n\nexport interface PluginOptions {\n  astroSortOrder: SortOrder;\n  astroAllowShorthand: boolean;\n}\n\nexport const options: Record<keyof PluginOptions, SupportOption> = {\n  astroSortOrder: {\n    since: '0.0.1',\n    category: 'Astro',\n    type: 'choice',\n    default: 'markup | styles',\n    description: 'Sort order for markup, scripts, and styles',\n    choices: [\n      {\n        value: 'markup | styles',\n        description: 'markup | styles',\n      },\n      {\n        value: 'styles | markup',\n        description: 'styles | markup',\n      },\n    ],\n  },\n  astroAllowShorthand: {\n    since: '0.0.10',\n    category: 'Astro',\n    type: 'boolean',\n    default: false,\n    description:\n      'Enable/disable attribute shorthand if attribute name and expression are the same',\n  },\n};\n\nexport const parseSortOrder = (sortOrder: SortOrder): SortOrderPart[] =>\n  sortOrder.split(' | ') as SortOrderPart[];\n\nexport type SortOrder = 'markup | styles' | 'styles | markup';\n\nexport type SortOrderPart = 'markup' | 'styles';\n","import printer from './printer';\nimport { options } from './options';\nimport { Parser, Printer, SupportLanguage } from 'prettier';\nimport { createSyncFn } from 'synckit';\nimport { createRequire } from 'module';\nconst require = createRequire(import.meta.url);\n\n// the worker path must be absolute\nconst parse = createSyncFn(require.resolve('../workers/parse-worker.js'));\n\nexport const languages: Partial<SupportLanguage>[] = [\n  {\n    name: 'astro',\n    parsers: ['astro'],\n    extensions: ['.astro'],\n    vscodeLanguageIds: ['astro'],\n  },\n];\n\nexport const parsers: Record<string, Parser> = {\n  astro: {\n    parse: (source) => parse(source),\n    astFormat: 'astro',\n    locStart: (node) => node.start,\n    locEnd: (node) => node.end,\n  },\n};\n\nexport const printers: Record<string, Printer> = {\n  astro: printer,\n};\n\nconst defaultOptions = {\n  tabWidth: 2,\n};\n\nexport { options, defaultOptions };\n"],"names":["require","createRequire","createSyncFn","_doc","SassFormatter"],"mappings":";;;;;;;;;;;;;AAoKA,MAAM,cAAc,GAAG;IACrB,SAAS;IACT,SAAS;IACT,OAAO;IACP,YAAY;IACZ,SAAS;IACT,QAAQ;IACR,IAAI;IACJ,KAAK;IACL,IAAI;IACJ,IAAI;IACJ,UAAU;IACV,YAAY;IACZ,QAAQ;IACR,QAAQ;IACR,MAAM;IACN,IAAI;IACJ,IAAI;IACJ,IAAI;IACJ,IAAI;IACJ,IAAI;IACJ,IAAI;IACJ,QAAQ;IACR,QAAQ;IACR,IAAI;IACJ,IAAI;IACJ,MAAM;IACN,KAAK;IACL,IAAI;IACJ,GAAG;IACH,KAAK;IACL,SAAS;IACT,OAAO;IACP,IAAI;IAEJ,OAAO;IACP,MAAM;CACE,CAAC;AAEJ,MAAM,aAAa,GAAa,CAAC,GAAG,cAAc,CAAC,CAAC;AAgEpD,MAAM,eAAe,GAAG;IAC7B,MAAM;IACN,MAAM;IACN,IAAI;IACJ,KAAK;IACL,OAAO;IACP,IAAI;IACJ,KAAK;IACL,OAAO;IACP,MAAM;IACN,MAAM;IACN,OAAO;IACP,QAAQ;IACR,OAAO;IACP,KAAK;CACN;;ACvPD,MAAMA,SAAO,GAAGC,sBAAa,CAAC,mMAAe,CAAC,CAAC;AAG/C,MAAM,SAAS,GAAGC,oBAAY,CAC5BF,SAAO,CAAC,OAAO,CAAC,gCAAgC,CAAC,CAClD,CAAC;AAQK,MAAM,qBAAqB,GAAa,EAI9C,CAAC;AAmBK,MAAM,eAAe,GAAG,CAAC,IAAU,KAAa;AACrD,IAAA,OAAO,CAAC,CAAC,IAAI,IAAI,IAAI,CAAC,IAAI,KAAK,MAAM,IAAI,gBAAgB,CAAC,IAAI,CAAC,CAAC,IAAI,EAAE,KAAK,EAAE,CAAC;AAChF,CAAC,CAAC;AAEK,MAAM,eAAe,GAAG,CAAC,IAAa,KAAa;AACxD,IAAA,IAAI,CAAC,IAAI,IAAI,CAAC,IAAI,CAAC,KAAK,IAAI,CAAC,KAAK,CAAC,OAAO,CAAC,IAAI,CAAC,KAAK,CAAC;AAAE,QAAA,OAAO,KAAK,CAAC;IACrE,OAAO,IAAI,CAAC,KAAK,CAAC,IAAI,CACpB,CAAC,IAAa,KACZ,CAAC,IAAI,CAAC,IAAI,KAAK,SAAS,IAAI,IAAI,CAAC,IAAI,CAAC,WAAW,EAAE,KAAK,KAAK;AAC7D,SAAC,IAAI,CAAC,IAAI,KAAK,WAAW,IAAI,CAAC,qBAAqB,CAAC,QAAQ,CAAC,IAAI,CAAC,IAAI,CAAC,CAAC,CAC5E,CAAC;AACJ,CAAC,CAAC;AAuEI,SAAU,gBAAgB,CAAC,IAAkB,EAAA;IACjD,OAAO,IAAI,CAAC,KAAK,CAAC;AACpB,CAAC;SAoBe,QAAQ,CACtB,IAAa,EACb,8BAA8B,GAAG,KAAK,EAAA;AAEtC,IAAA,IAAI,CAAC,kBAAkB,CAAC,IAAI,CAAC,EAAE;AAC7B,QAAA,OAAO,EAAE,CAAC;AACX,KAAA;AAED,IAAA,IAAI,IAAI,CAAC,QAAQ,CAAC,MAAM,KAAK,CAAC,EAAE;AAC9B,QAAA,OAAO,EAAE,CAAC;AACX,KAAA;IAED,IAAI,GAAG,GAAG,IAAI,CAAC,QAAQ,CAAC,MAAM,CAC5B,CAAC,IAAY,EAAE,IAAU,KAAK,IAAI,GAAG,SAAS,CAAC,IAAI,CAAC,EACpD,EAAE,CACH,CAAC;IAEF,IAAI,CAAC,8BAA8B,EAAE;AACnC,QAAA,OAAO,GAAG,CAAC;AACZ,KAAA;AAED,IAAA,IAAI,mBAAmB,CAAC,GAAG,CAAC,EAAE;AAC5B,QAAA,GAAG,GAAG,GAAG,CAAC,SAAS,CAAC,GAAG,CAAC,OAAO,CAAC,IAAI,CAAC,GAAG,CAAC,CAAC,CAAC;AAC5C,KAAA;AACD,IAAA,IAAI,iBAAiB,CAAC,GAAG,CAAC,EAAE;AAC1B,QAAA,GAAG,GAAG,GAAG,CAAC,SAAS,CAAC,CAAC,EAAE,GAAG,CAAC,WAAW,CAAC,IAAI,CAAC,CAAC,CAAC;AAC9C,QAAA,IAAI,GAAG,CAAC,MAAM,CAAC,GAAG,CAAC,MAAM,GAAG,CAAC,CAAC,KAAK,IAAI,EAAE;AACvC,YAAA,GAAG,GAAG,GAAG,CAAC,SAAS,CAAC,CAAC,EAAE,GAAG,CAAC,MAAM,GAAG,CAAC,CAAC,CAAC;AACxC,SAAA;AACF,KAAA;AAED,IAAA,OAAO,GAAG,CAAC;AACb,CAAC;AAEK,SAAU,kBAAkB,CAChC,IAAa,EAAA;AAEb,IAAA,OAAO,IAAI,IAAI,UAAU,IAAI,IAAI,IAAI,KAAK,CAAC,OAAO,CAAC,IAAI,CAAC,QAAQ,CAAC,CAAC;AACpE,CAAC;SAEe,eAAe,CAC7B,IAAa,EACb,IAAmB,EACnB,IAAa,EAAA;AAEb,IAAA,QACE,IAAI;QACJ,IAAI,CAAC,IAAI,KAAK,SAAS;AACvB,QAAA,CAAC,cAAc,CAAC,IAAI,EAAE,IAAI,CAAC;AAC3B,QAAA,CAAC,eAAe,CAAC,IAAI,CAAC,EACtB;AACJ,CAAC;AAEe,SAAA,cAAc,CAC5B,IAAa,EACb,IAAmB,EAAA;AAEnB,IAAA,QACE,IAAI;QACJ,IAAI,CAAC,IAAI,KAAK,SAAS;QACvB,IAAI,CAAC,yBAAyB,KAAK,QAAQ;AAC3C,SAAC,IAAI,CAAC,yBAAyB,KAAK,QAAQ;YAC1C,aAAa,CAAC,QAAQ,CAAC,IAAI,CAAC,IAAI,CAAC,CAAC,EACpC;AACJ,CAAC;SAEe,+BAA+B,CAC7C,IAAc,EACd,OAAO,GAAG,CAAC,EAAA;IAEX,OAAO,mBAAmB,CAAC,gBAAgB,CAAC,IAAI,CAAC,EAAE,OAAO,CAAC,CAAC;AAE9D,CAAC;SAEe,mBAAmB,CAAC,IAAY,EAAE,OAAO,GAAG,CAAC,EAAA;AAC3D,IAAA,OAAO,IAAI,MAAM,CAAC,CAAA,oBAAA,EAAuB,OAAO,CAAA,CAAA,CAAG,CAAC,CAAC,IAAI,CAAC,IAAI,CAAC,CAAC;AAClE,CAAC;SAMe,iBAAiB,CAAC,IAAY,EAAE,OAAO,GAAG,CAAC,EAAA;AACzD,IAAA,OAAO,IAAI,MAAM,CAAC,CAAA,mBAAA,EAAsB,OAAO,CAAA,EAAA,CAAI,CAAC,CAAC,IAAI,CAAC,IAAI,CAAC,CAAC;AAClE,CAAC;AAEK,SAAU,gCAAgC,CAAC,IAAU,EAAA;AACzD,IAAA,OAAO,IAAI,CAAC,IAAI,KAAK,MAAM,IAAI,KAAK,CAAC,IAAI,CAAC,gBAAgB,CAAC,IAAI,CAAC,CAAC,CAAC;AACpE,CAAC;AAEK,SAAU,8BAA8B,CAAC,IAAU,EAAA;AACvD,IAAA,OAAO,IAAI,CAAC,IAAI,KAAK,MAAM,IAAI,KAAK,CAAC,IAAI,CAAC,gBAAgB,CAAC,IAAI,CAAC,CAAC,CAAC;AACpE,CAAC;AAEK,SAAU,mBAAmB,CAAC,SAAiB,EAAA;IAGnD,OAAO,CAAA,CAAA,EAAI,SAAS,CAAA,GAAA,CAAK,CAAC;AAC5B,CAAC;AAMe,SAAA,cAAc,CAAC,IAAa,EAAE,IAAmB,EAAA;AAC/D,IAAA,IAAI,cAAc,CAAC,IAAI,EAAE,IAAI,CAAC,EAAE;AAC9B,QAAA,OAAO,KAAK,CAAC;AACd,KAAA;AAED,IAAA,IAAI,CAAC,kBAAkB,CAAC,IAAI,CAAC,EAAE;AAC7B,QAAA,OAAO,KAAK,CAAC;AACd,KAAA;AAED,IAAA,MAAM,QAAQ,GAAG,IAAI,CAAC,QAAQ,CAAC;AAC/B,IAAA,IAAI,QAAQ,CAAC,MAAM,KAAK,CAAC,EAAE;AACzB,QAAA,OAAO,IAAI,CAAC;AACb,KAAA;AAED,IAAA,MAAM,UAAU,GAAG,QAAQ,CAAC,CAAC,CAAC,CAAC;AAC/B,IAAA,OAAO,CAAC,gCAAgC,CAAC,UAAU,CAAC,CAAC;AACvD,CAAC;AAMe,SAAA,YAAY,CAAC,IAAa,EAAE,IAAmB,EAAA;AAC7D,IAAA,IAAI,cAAc,CAAC,IAAI,EAAE,IAAI,CAAC,EAAE;AAC9B,QAAA,OAAO,KAAK,CAAC;AACd,KAAA;AAED,IAAA,IAAI,CAAC,kBAAkB,CAAC,IAAI,CAAC,EAAE;AAC7B,QAAA,OAAO,KAAK,CAAC;AACd,KAAA;AAED,IAAA,MAAM,QAAQ,GAAG,IAAI,CAAC,QAAQ,CAAC;AAC/B,IAAA,IAAI,QAAQ,CAAC,MAAM,KAAK,CAAC,EAAE;AACzB,QAAA,OAAO,IAAI,CAAC;AACb,KAAA;AAED,IAAA,OAAO,KAAK,CAAC;AAKf,CAAC;AAKe,SAAA,+BAA+B,CAC7C,IAAa,EACb,IAAmB,EAAA;AAEnB,IAAA,OAAO,mCAAmC,CAAC,IAAI,EAAE,IAAI,CAAC,CAAC;AAGzD,CAAC;AAeD,SAAS,WAAW,CAAC,IAAa,EAAA;AAChC,IAAA,OAAO,kBAAkB,CAAC,IAAI,CAAC,GAAG,IAAI,CAAC,QAAQ,GAAG,EAAE,CAAC;AACvD,CAAC;AAED,SAAS,mCAAmC,CAC1C,IAAa,EACb,IAAmB,EAAA;AAEnB,IAAA,MAAM,MAAM,GAAG,IAAI,CAAC,aAAa,EAAE,CAAC;IACpC,IAAI,CAAC,MAAM,IAAI,CAAC,cAAc,CAAC,MAAM,EAAE,IAAI,CAAC,EAAE;AAC5C,QAAA,OAAO,KAAK,CAAC;AACd,KAAA;AAED,IAAA,MAAM,QAAQ,GAAG,WAAW,CAAC,MAAM,CAAC,CAAC;IACrC,MAAM,SAAS,GAAG,QAAQ,CAAC,QAAQ,CAAC,MAAM,GAAG,CAAC,CAAC,CAAC;AAChD,IAAA,OAAO,SAAS,KAAK,IAAI,CAAC,OAAO,EAAE,CAAC;AACtC,CAAC;AAEK,SAAU,gBAAgB,CAAC,IAAc,EAAA;AAC7C,IAAA,IAAI,CAAC,KAAK,GAAG,IAAI,CAAC,KAAK,IAAI,IAAI,CAAC,KAAK,CAAC,SAAS,EAAE,CAAC;AACpD,CAAC;AAEK,SAAU,iBAAiB,CAAC,IAAc,EAAA;AAC9C,IAAA,IAAI,CAAC,KAAK,GAAG,IAAI,CAAC,KAAK,IAAI,IAAI,CAAC,KAAK,CAAC,OAAO,EAAE,CAAC;AAClD,CAAC;AA+QK,SAAU,YAAY,CAAC,KAAa,EAAA;IAKxC,IAAI,UAAU,GAAG,QAAQ,CAAC;IAC1B,IAAI,MAAM,GAAG,KAAK,CAAC;IAEnB,MAAM,GAAG,MAAM,CAAC,OAAO,CAAC,OAAO,EAAE,IAAI,CAAC,CAAC;IAGvC,IAAI,IAAI,GAAG,EAAE,CAAC;IACd,KAAK,MAAM,IAAI,IAAI,MAAM,CAAC,KAAK,CAAC,IAAI,CAAC,EAAE;AACrC,QAAA,IAAI,CAAC,IAAI;YAAE,SAAS;AAEpB,QAAA,IAAI,IAAI,CAAC,CAAC,CAAC,IAAI,QAAQ,CAAC,IAAI,CAAC,IAAI,CAAC,CAAC,CAAC,CAAC,EAAE;YACrC,UAAU,GAAG,CAAC,CAAC;YACf,MAAM;AACP,SAAA;QACD,MAAM,KAAK,GAAG,IAAI,CAAC,KAAK,CAAC,WAAW,CAAC,CAAC;AACtC,QAAA,IAAI,KAAK,EAAE;AACT,YAAA,IAAI,KAAK,CAAC,CAAC,CAAC,IAAI,CAAC,IAAI;gBAAE,IAAI,GAAG,KAAK,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC;AAC1C,YAAA,IAAI,KAAK,CAAC,CAAC,CAAC,CAAC,MAAM,GAAG,UAAU;AAAE,gBAAA,UAAU,GAAG,KAAK,CAAC,CAAC,CAAC,CAAC,MAAM,CAAC;AAChE,SAAA;AACF,KAAA;IAGD,IAAI,UAAU,GAAG,CAAC,IAAI,MAAM,CAAC,QAAQ,CAAC,UAAU,CAAC,EAAE;AACjD,QAAA,MAAM,GAAG,MAAM,CAAC,OAAO,CACrB,IAAI,MAAM,CAAC,CAAI,CAAA,EAAA,IAAI,KAAK,CAAC,UAAU,GAAG,CAAC,CAAC,CAAC,IAAI,CAAC,IAAI,CAAC,CAAA,CAAE,EAAE,IAAI,CAAC,EAC5D,EAAE,CACH,CAAC;AACH,KAAA;IAED,OAAO;QACL,OAAO,EAAE,UAAU,KAAK,QAAQ,GAAG,CAAC,GAAG,UAAU;QACjD,IAAI;QACJ,MAAM;KACP,CAAC;AACJ,CAAC;AAQK,SAAU,eAAe,CAAC,MAAc,EAAA;AAE5C,IAAA,IAAI,YAAY,CAAC;AACjB,IAAA,QACG,YAAY;AACX,QAAA,uEAAuE,CAAC,IAAI,CAC1E,MAAM,CACP,GACH;QACA,IAAI,YAAY,CAAC,CAAC,CAAC;AAAE,YAAA,OAAO,IAAI,GAAG,CAAC,CAAC,YAAY,CAAC,CAAC,CAAC,CAAC,IAAI,EAAE,CAAC,CAAC,CAAC;AAC/D,KAAA;AAGD,IAAA,IAAI,UAAU,CAAC;AACf,IAAA,QACG,UAAU;AACT,QAAA,4DAA4D,CAAC,IAAI,CAAC,MAAM,CAAC,GAC3E;AACA,QAAA,IAAI,UAAU,CAAC,CAAC,CAAC,IAAI,CAAC,UAAU,CAAC,CAAC,CAAC,CAAC,QAAQ,CAAC,UAAU,CAAC;YAAE,SAAS;AAEnE,QAAA,MAAM,UAAU,GAAG,UAAU,CAAC,CAAC,CAAC;AAC7B,aAAA,IAAI,EAAE;AACN,aAAA,OAAO,CAAC,KAAK,EAAE,EAAE,CAAC;AAClB,aAAA,OAAO,CAAC,KAAK,EAAE,EAAE,CAAC;AAClB,aAAA,IAAI,EAAE,CAAC;QACV,IAAI,UAAU,GAAG,UAAU,CAAC;QAC5B,KAAK,MAAM,IAAI,IAAI,UAAU,CAAC,KAAK,CAAC,GAAG,CAAC,EAAE;YACxC,MAAM,CAAC,QAAQ,EAAE,OAAO,CAAC,GAAG,IAAI,CAAC,KAAK,CAAC,MAAM,CAAC,CAAC,GAAG,CAAC,CAAC,CAAC,KAAK,CAAC,CAAC,IAAI,EAAE,CAAC,CAAC;YACpE,IAAI,QAAQ,KAAK,UAAU;gBAAE,SAAS;AACtC,YAAA,UAAU,GAAG,OAAO,IAAI,QAAQ,CAAC;YACjC,MAAM;AACP,SAAA;AACD,QAAA,OAAO,IAAI,GAAG,CAAC,CAAC,UAAU,CAAC,CAAC,CAAC;AAC9B,KAAA;AACD,IAAA,OAAO,IAAI,GAAG,CAAC,CAAC,UAAU,CAAC,CAAC,CAAC;AAC/B,CAAC;AAIK,SAAU,UAAU,CAAC,IAAa,EAAA;AACtC,IAAA,OAAO,IAAI,CAAC,IAAI,KAAK,MAAM,CAAC;AAC9B,CAAC;AAuBK,SAAU,gBAAgB,CAAC,IAAc,EAAA;AAC7C,IAAA,IAAI,CAAC,QAAQ,GAAG,IAAI,CAAC,QAAQ,CAAC,MAAM,CAAC,CAAC,IAAI,EAAE,CAAC,EAAE,YAAY,KAAI;AAC7D,QAAA,IAAI,IAAI,CAAC,IAAI,KAAK,MAAM;AAAE,YAAA,OAAO,IAAI,CAAC;AAEtC,QAAA,QACE,CAAC;AACD,YAAA,YAAY,CAAC,SAAS,CAAC,CAAC,CAAC,KAAI;AAC3B,gBAAA,IAAI,CAAC,CAAC,QAAQ,IAAI,IAAI,CAAC,QAAQ,EAAE;AAC/B,oBAAA,QACE,IAAI,CAAC,IAAI,KAAK,MAAM;AACpB,wBAAA,CAAC,CAAC,QAAQ,CAAC,KAAK,CAAC,MAAM,KAAK,IAAI,CAAC,QAAQ,CAAC,KAAK,CAAC,MAAM;AACtD,wBAAA,CAAC,CAAC,QAAQ,CAAC,KAAK,CAAC,IAAI,KAAK,IAAI,CAAC,QAAQ,CAAC,KAAK,CAAC,IAAI;AAClD,wBAAA,CAAC,CAAC,QAAQ,CAAC,KAAK,CAAC,MAAM,KAAK,IAAI,CAAC,QAAQ,CAAC,KAAK,CAAC,MAAM,EACtD;AACH,iBAAA;aACF,CAAC,EACF;AACJ,KAAC,CAAC,CAAC;AACL,CAAC;AAKK,SAAU,aAAa,CAAC,IAAa,EAAA;AACzC,IAAA,QACE,IAAI,CAAC,IAAI,KAAK,SAAS;QACvB,IAAI,CAAC,IAAI,KAAK,WAAW;QACzB,IAAI,CAAC,IAAI,KAAK,gBAAgB;AAC9B,QAAA,IAAI,CAAC,IAAI,KAAK,UAAU,EACxB;AACJ,CAAC;AAKK,SAAU,WAAW,CAAC,IAAa,EAAA;AACvC,IAAA,MAAM,MAAM,GAAG,IAAI,CAAC,aAAa,EAAE,CAAC;AACpC,IAAA,IAAI,CAAC,MAAM;AAAE,QAAA,OAAO,EAAE,CAAC;AAEvB,IAAA,OAAO,WAAW,CAAC,MAAM,CAAC,CAAC;AAC7B,CAAC;AAEK,SAAU,WAAW,CAAC,IAAa,EAAA;;AACvC,IAAA,MAAM,IAAI,GAAG,IAAI,CAAC,OAAO,EAAE,CAAC;AAC5B,IAAA,IAAI,IAAI,EAAE;AACR,QAAA,MAAM,QAAQ,GAAG,WAAW,CAAC,IAAI,CAAC,CAAC;QACnC,IAAI,CAAA,MAAA,IAAI,CAAC,QAAQ,MAAE,IAAA,IAAA,EAAA,KAAA,KAAA,CAAA,GAAA,KAAA,CAAA,GAAA,EAAA,CAAA,KAAK,OAAK,CAAA,EAAA,GAAA,QAAQ,CAAC,QAAQ,CAAC,MAAM,GAAG,CAAC,CAAC,CAAC,QAAQ,MAAE,IAAA,IAAA,EAAA,KAAA,KAAA,CAAA,GAAA,KAAA,CAAA,GAAA,EAAA,CAAA,KAAK,CAAA;AACxE,YAAA,OAAO,IAAI,CAAC;AACd,QAAA,KAAK,IAAI,CAAC,GAAG,CAAC,EAAE,CAAC,GAAG,QAAQ,CAAC,MAAM,EAAE,CAAC,EAAE,EAAE;AACxC,YAAA,MAAM,OAAO,GAAG,QAAQ,CAAC,CAAC,CAAC,CAAC;AAC5B,YAAA,IACE,CAAA,CAAA,EAAA,GAAA,OAAO,CAAC,QAAQ,MAAE,IAAA,IAAA,EAAA,KAAA,KAAA,CAAA,GAAA,KAAA,CAAA,GAAA,EAAA,CAAA,KAAK,OAAK,CAAA,EAAA,GAAA,IAAI,CAAC,QAAQ,MAAA,IAAA,IAAA,EAAA,KAAA,KAAA,CAAA,GAAA,KAAA,CAAA,GAAA,EAAA,CAAE,KAAK,CAAA;AAChD,gBAAA,CAAC,KAAK,QAAQ,CAAC,MAAM,GAAG,CAAC,EACzB;AACA,gBAAA,OAAO,QAAQ,CAAC,CAAC,GAAG,CAAC,CAAC,CAAC;AACxB,aAAA;AACF,SAAA;AACF,KAAA;AACD,IAAA,OAAO,IAAI,CAAC;AACd;;ACpyBA,MAAM,EACJ,QAAQ,EAAE,EACR,WAAW,EACX,MAAM,EACN,IAAI,EACJ,KAAK,EACL,QAAQ,EACR,MAAM,EACN,IAAI,EACJ,IAAI,EACJ,WAAW,EACX,QAAQ,GACT,EACD,KAAK,EAAE,EAAE,WAAW,EAAE,qBAAqB,EAAE,GAC9C,GAAGG,wBAAI,CAAC;AA4GT,SAAS,YAAY,CAAC,WAAoB,EAAE,OAAsB,EAAA;AAGhE,IAAA,OAAO,WAAW,CAAC;AACrB,CAAC;AAKD,SAAS,KAAK,CAAC,IAAa,EAAE,IAAmB,EAAE,KAAc,EAAA;AAC/D,IAAA,MAAM,IAAI,GAAG,IAAI,CAAC,QAAQ,EAAE,CAAC;IAI7B,IAAI,CAAC,IAAI,EAAE;AACT,QAAA,OAAO,EAAE,CAAC;AACX,KAAA;AAED,IAAA,IAAI,OAAO,IAAI,KAAK,QAAQ,EAAE;AAC5B,QAAA,OAAO,IAAI,CAAC;AACb,KAAA;IAgBD,QAAQ,IAAI,CAAC,IAAI;QACf,KAAK,MAAM,EAAE;YACX,gBAAgB,CAAC,IAAI,CAAC,CAAC;AACvB,YAAA,OAAO,CAAC,qBAAqB,CAAC,IAAI,CAAC,GAAG,CAAC,KAAK,EAAE,UAAU,CAAC,CAAC,EAAE,QAAQ,CAAC,CAAC;AACvE,SAAA;QA6BD,KAAK,MAAM,EAAE;AACX,YAAA,MAAM,OAAO,GAAG,gBAAgB,CAAC,IAAI,CAAC,CAAC;AAYvC,YAAA,IAAI,eAAe,CAAC,IAAI,CAAC,EAAE;AACzB,gBAAA,MAAM,aAAa,GACjB,OAAO,CAAC,IAAI,EAAE,CAAC,MAAM,GAAG,gBAAgB,CAAC,IAAI,CAAC,CAAC,MAAM,CAAC;gBACxD,MAAM,oBAAoB,GAAG,IAAI,CAAC,IAAI,CAAC,gBAAgB,CAAC,IAAI,CAAC,CAAC,CAAC;gBAC/D,MAAM,oBAAoB,GAAG,eAAe,CAAC,IAAI,CAC/C,gBAAgB,CAAC,IAAI,CAAC,CACvB,CAAC;AACF,gBAAA,IAAI,oBAAoB,EAAE;AACxB,oBAAA,OAAO,CAAC,QAAQ,EAAE,QAAQ,CAAC,CAAC;AAC7B,iBAAA;AACD,gBAAA,IAAI,oBAAoB,EAAE;AACxB,oBAAA,OAAO,QAAQ,CAAC;AACjB,iBAAA;AACD,gBAAA,IAAI,aAAa,EAAE;AACjB,oBAAA,OAAO,IAAI,CAAC;AACb,iBAAA;AACD,gBAAA,OAAO,EAAE,CAAC;AACX,aAAA;AAQD,YAAA,OAAO,IAAI,CAAC,eAAe,CAAC,IAAI,CAAC,CAAC,CAAC;AACpC,SAAA;AAID,QAAA,KAAK,WAAW,CAAC;AACjB,QAAA,KAAK,UAAU,CAAC;QAChB,KAAK,SAAS,EAAE;AAEd,YAAA,IAAI,OAAgB,CAAC;AACrB,YAAA,IAAI,CAAC,IAAI,CAAC,QAAQ,EAAE;gBAClB,OAAO,GAAG,IAAI,CAAC;AAChB,aAAA;AAAM,iBAAA;AACL,gBAAA,OAAO,GAAG,IAAI,CAAC,QAAQ,CAAC,KAAK,CAAC,CAAC,KAAK,KAAK,eAAe,CAAC,KAAK,CAAC,CAAC,CAAC;AAClE,aAAA;YACD,MAAM,gBAAgB,GACpB,OAAO;AACP,iBAAC,IAAI,CAAC,IAAI,KAAK,SAAS,IAAI,eAAe,CAAC,OAAO,CAAC,IAAI,CAAC,IAAI,CAAC,KAAK,CAAC,CAAC,CAAC,CAAC;YAEzE,MAAM,UAAU,GAAG,IAAI,CAAC,GAAG,CAAC,KAAK,EAAE,YAAY,CAAC,CAAC;AACjD,YAAA,IAAI,gBAAgB,EAAE;gBACpB,OAAO,KAAK,CAAC,CAAC,GAAG,EAAE,IAAI,CAAC,IAAI,EAAE,MAAM,CAAC,KAAK,CAAC,UAAU,CAAC,CAAC,EAAE,IAAI,EAAE,CAAA,EAAA,CAAI,CAAC,CAAC,CAAC;AAEvE,aAAA;YAED,IAAI,IAAI,CAAC,QAAQ,EAAE;AACjB,gBAAA,MAAM,QAAQ,GAAG,IAAI,CAAC,QAAQ,CAAC;AAC/B,gBAAA,MAAM,UAAU,GAAG,QAAQ,CAAC,CAAC,CAAC,CAAC;gBAC/B,MAAM,SAAS,GAAG,QAAQ,CAAC,QAAQ,CAAC,MAAM,GAAG,CAAC,CAAC,CAAC;gBAGhD,IAAI,mBAAmB,GAIV,QAAQ,CAAC;gBACtB,IAAI,iBAAiB,GAIR,QAAQ,CAAC;gBACtB,MAAM,QAAQ,GAAG,cAAc,CAAC,IAAI,EAAE,IAAI,CAAC,CAAC;gBAC5C,MAAM,MAAM,GAAG,YAAY,CAAC,IAAI,EAAE,IAAI,CAAC,CAAC;AAExC,gBAAA,IAAI,IAAI,CAAC;AAET,gBAAA,IAAI,OAAO,EAAE;oBACX,IAAI;AACF,wBAAA,eAAe,CAAC,IAAI,EAAE,IAAI,EAAE,IAAI,CAAC;4BACjC,IAAI,CAAC,QAAQ,CAAC,MAAM;AACpB,4BAAA,gCAAgC,CAAC,IAAI,CAAC,QAAQ,CAAC,CAAC,CAAC,CAAC;4BAClD,CAAC,eAAe,CAAC,IAAI,CAAC;AACpB,8BAAE,MAAM,IAAI;;gCAEV,MAAM,QAAQ,CAAC;AACtB,iBAAA;AAAM,qBAAA,IAAI,eAAe,CAAC,IAAI,CAAC,EAAE;oBAChC,IAAI,GAAG,MAAM,QAAQ,CAAC,IAAI,CAAC,CAAC;AAC7B,iBAAA;AAAM,qBAAA,IACL,eAAe,CAAC,IAAI,EAAE,IAAI,EAAE,IAAI,CAAC;AACjC,oBAAA,CAAC,eAAe,CAAC,IAAI,CAAC,EACtB;AACA,oBAAA,IAAI,GAAG,MAAM,IAAI,CAAC,GAAG,CAAC,KAAK,EAAE,UAAU,CAAC,CAAC;AAC1C,iBAAA;AAAM,qBAAA;AACL,oBAAA,IAAI,GAAG,MAAM,IAAI,CAAC,GAAG,CAAC,KAAK,EAAE,UAAU,CAAC,CAAC;AAC1C,iBAAA;AAED,gBAAA,MAAM,UAAU,GAAG;oBACjB,GAAG;AACH,oBAAA,IAAI,CAAC,IAAI;oBACT,MAAM,CACJ,KAAK,CAAC;AACJ,wBAAA,GAAG,UAAU;wBACb,QAAQ;AACN,8BAAE,EAAE;8BACF,CAAC,eAAe,CAAC,IAAI,CAAC,IAAI,CAAC,IAAI,CAAC,eAAe;AACjD,kCAAE,MAAM,CAAC,QAAQ,CAAC;AAClB,kCAAE,EAAE;AACP,qBAAA,CAAC,CACH;iBACF,CAAC;gBAGF,IAAI,QAAQ,IAAI,MAAM,EAAE;AACtB,oBAAA,MAAM,aAAa,GAAG;wBACpB,QAAQ;AACR,wBAAA,KAAK,CAAC,CAAC,GAAG,EAAE,IAAI,EAAE,EAAE,CAAA,EAAA,EAAK,IAAI,CAAC,IAAI,CAAA,CAAE,CAAC,CAAC;qBACvC,CAAC;oBAEF,MAAM,4BAA4B,GAChC,OAAO,IAAI,+BAA+B,CAAC,IAAI,EAAE,IAAI,CAAC,CAAC;AAEzD,oBAAA,OAAO,KAAK,CAAC;AACX,wBAAA,GAAG,UAAU;AACb,wBAAA,OAAO,GAAG,KAAK,CAAC,aAAa,CAAC,GAAG,KAAK,CAAC,MAAM,CAAC,aAAa,CAAC,CAAC;AAC7D,wBAAA,4BAA4B,GAAG,EAAE,GAAG,QAAQ;wBAC5C,GAAG;AACJ,qBAAA,CAAC,CAAC;AACJ,iBAAA;AAED,gBAAA,IAAI,eAAe,CAAC,IAAI,CAAC,EAAE;oBACzB,mBAAmB,GAAG,EAAE,CAAC;oBACzB,iBAAiB,GAAG,EAAE,CAAC;AACxB,iBAAA;AAAM,qBAAA;oBACL,IAAI,kBAAkB,GAAG,KAAK,CAAC;oBAE/B,IAAI,CAAC,QAAQ,IAAI,UAAU,IAAI,UAAU,CAAC,UAAU,CAAC,EAAE;wBACrD,IACE,+BAA+B,CAAC,UAAU,CAAC;AAC3C,4BAAA,UAAU,KAAK,SAAS;6BACvB,CAAC,eAAe,CAAC,IAAI,EAAE,IAAI,EAAE,IAAI,CAAC;AACjC,gCAAA,8BAA8B,CAAC,SAAS,CAAC,CAAC,EAC5C;4BACA,mBAAmB,GAAG,QAAQ,CAAC;4BAC/B,iBAAiB,GAAG,QAAQ,CAAC;4BAC7B,kBAAkB,GAAG,IAAI,CAAC;AAC3B,yBAAA;6BAAM,IAAI,eAAe,CAAC,IAAI,EAAE,IAAI,EAAE,IAAI,CAAC,EAAE;4BAC5C,mBAAmB,GAAG,IAAI,CAAC;AAC5B,yBAAA;wBACD,gBAAgB,CAAC,UAAU,CAAC,CAAC;AAC9B,qBAAA;oBACD,IAAI,CAAC,MAAM,IAAI,SAAS,IAAI,UAAU,CAAC,SAAS,CAAC,EAAE;wBACjD,IAAI,eAAe,CAAC,IAAI,EAAE,IAAI,EAAE,IAAI,CAAC,IAAI,CAAC,kBAAkB,EAAE;4BAC5D,iBAAiB,GAAG,QAAQ,CAAC;AAC9B,yBAAA;wBACD,iBAAiB,CAAC,SAAS,CAAC,CAAC;AAC9B,qBAAA;AACF,iBAAA;AAED,gBAAA,IAAI,QAAQ,EAAE;AACZ,oBAAA,OAAO,KAAK,CAAC;AACX,wBAAA,GAAG,UAAU;AACb,wBAAA,MAAM,CAAC,CAAC,QAAQ,EAAE,KAAK,CAAC,CAAC,GAAG,EAAE,IAAI,EAAE,CAAC,CAAC,CAAC,CAAC;wBACxC,iBAAiB;wBACjB,CAAK,EAAA,EAAA,IAAI,CAAC,IAAI,CAAG,CAAA,CAAA;AAClB,qBAAA,CAAC,CAAC;AACJ,iBAAA;AAED,gBAAA,IAAI,MAAM,EAAE;AACV,oBAAA,OAAO,KAAK,CAAC;AACX,wBAAA,GAAG,UAAU;wBACb,GAAG;AACH,wBAAA,MAAM,CAAC,CAAC,mBAAmB,EAAE,KAAK,CAAC,CAAC,IAAI,EAAE,EAAE,CAAA,EAAA,EAAK,IAAI,CAAC,IAAI,EAAE,CAAC,CAAC,CAAC,CAAC;AAChE,wBAAA,+BAA+B,CAAC,IAAI,EAAE,IAAI,CAAC,GAAG,EAAE,GAAG,QAAQ;wBAC3D,GAAG;AACJ,qBAAA,CAAC,CAAC;AACJ,iBAAA;AAED,gBAAA,IAAI,OAAO,EAAE;AACX,oBAAA,OAAO,KAAK,CAAC,CAAC,GAAG,UAAU,EAAE,GAAG,EAAE,IAAI,EAAE,EAAE,KAAK,IAAI,CAAC,IAAI,CAAG,CAAA,CAAA,CAAC,CAAC,CAAC;AAC/D,iBAAA;AAED,gBAAA,OAAO,KAAK,CAAC;AACX,oBAAA,GAAG,UAAU;oBACb,GAAG;AACH,oBAAA,MAAM,CAAC,CAAC,mBAAmB,EAAE,IAAI,EAAE,CAAC,CAAC;oBACrC,iBAAiB;oBACjB,CAAK,EAAA,EAAA,IAAI,CAAC,IAAI,CAAG,CAAA,CAAA;AAClB,iBAAA,CAAC,CAAC;AACJ,aAAA;AAED,YAAA,OAAO,EAAE,CAAC;AACX,SAAA;QAID,KAAK,WAAW,EAAE;YAChB,MAAM,IAAI,GAAG,IAAI,CAAC,IAAI,CAAC,IAAI,EAAE,CAAC;AAC9B,YAAA,MAAM,KAAK,GAAG,IAAI,CAAC,WAAW,GAAG,GAAG,GAAG,GAAG,CAAC;YAC3C,QAAQ,IAAI,CAAC,IAAI;AACf,gBAAA,KAAK,OAAO;AACV,oBAAA,OAAO,CAAC,IAAI,EAAE,IAAI,CAAC,CAAC;AACtB,gBAAA,KAAK,YAAY;AAEf,oBAAA,OAAO,EAAE,CAAC;AACZ,gBAAA,KAAK,QAAQ;AACX,oBAAA,OAAO,CAAC,IAAI,EAAE,IAAI,EAAE,GAAG,EAAE,KAAK,EAAE,IAAI,CAAC,KAAK,EAAE,KAAK,CAAC,CAAC;AACrD,gBAAA,KAAK,WAAW;oBACd,OAAO,CAAC,IAAI,EAAE,GAAG,EAAE,IAAI,EAAE,GAAG,CAAC,CAAC;AAChC,gBAAA,KAAK,QAAQ;oBACX,OAAO,CAAC,IAAI,EAAE,MAAM,EAAE,IAAI,EAAE,GAAG,CAAC,CAAC;AACnC,gBAAA,KAAK,kBAAkB;AACrB,oBAAA,OAAO,CAAC,IAAI,EAAE,IAAI,EAAE,GAAG,EAAE,GAAG,EAAE,IAAI,CAAC,KAAK,EAAE,GAAG,CAAC,CAAC;AAGlD,aAAA;AACD,YAAA,OAAO,EAAE,CAAC;AACX,SAAA;QAED,KAAK,SAAS,EAAE;AAEd,YAAA,OAAO,CAAC,iBAAiB,EAAE,QAAQ,CAAC,CAAC;AACtC,SAAA;AAuBD,QAAA,KAAK,SAAS;AACZ,YAAA,MAAM,QAAQ,GAAG,WAAW,CAAC,IAAI,CAAC,CAAC;YACnC,IAAI,YAAY,GAAkC,EAAE,CAAC;AACrD,YAAA,IAAI,QAAQ,IAAI,aAAa,CAAC,QAAQ,CAAC,EAAE;gBACvC,YAAY,GAAG,QAAQ,CAAC;AACzB,aAAA;AACD,YAAA,OAAO,CAAC,MAAM,EAAE,gBAAgB,CAAC,IAAI,CAAC,EAAE,KAAK,EAAE,YAAY,CAAC,CAAC;AAU/D,QAAA,SAAS;YACP,MAAM,IAAI,KAAK,CAAC,CAAA,qBAAA,EAAwB,IAAI,CAAC,IAAI,CAAI,EAAA,CAAA,CAAC,CAAC;AACxD,SAAA;AACF,KAAA;AACH,CAAC;AAQD,SAAS,eAAe,CAAC,IAAkB,EAAA;AACzC,IAAA,MAAM,IAAI,GAAG,gBAAgB,CAAC,IAAI,CAAC,CAAC;IAEpC,MAAM,SAAS,GAAG,IAAI,CAAC,KAAK,CAAC,cAAc,CAAC,CAAC;IAE7C,IAAI,IAAI,GAAG,IAAI,CAAC,IAAI,EAAE,SAAS,CAAC,CAAC,KAAK,CAAC,MAAM,CAAC,CAAC,CAAC,KAAK,CAAC,KAAK,EAAE,CAAC,CAAC;AAE/D,IAAA,IAAI,mBAAmB,CAAC,IAAI,CAAC,EAAE;AAC7B,QAAA,IAAI,CAAC,CAAC,CAAC,GAAG,QAAQ,CAAC;AACpB,KAAA;AACD,IAAA,IAAI,mBAAmB,CAAC,IAAI,EAAE,CAAC,CAAC,EAAE;AAChC,QAAA,IAAI,GAAG,CAAC,QAAQ,EAAE,GAAG,IAAI,CAAC,CAAC;AAC5B,KAAA;AAED,IAAA,IAAI,iBAAiB,CAAC,IAAI,CAAC,EAAE;QAC3B,IAAI,CAAC,IAAI,CAAC,MAAM,GAAG,CAAC,CAAC,GAAG,QAAQ,CAAC;AAClC,KAAA;AACD,IAAA,IAAI,iBAAiB,CAAC,IAAI,EAAE,CAAC,CAAC,EAAE;AAC9B,QAAA,IAAI,GAAG,CAAC,GAAG,IAAI,EAAE,QAAQ,CAAC,CAAC;AAC5B,KAAA;AAED,IAAA,OAAO,IAAI,CAAC;AACd,CAAC;AAED,SAAS,gBAAgB,CACvB,IAAY,EACZ,OAAuB,EACvB,IAAmB,EAAA;IAEnB,MAAM,GAAG,GAAG,OAAO,CAAC,KAAK,CAAC,IAAI,EAAE,IAAI,CAAC,CAAC;AAGtC,IAAA,OAAO,EAAE,GAAG,GAAG,EAAE,OAAO,EAAE,GAAG,CAAC,OAAO,CAAC,IAAI,CAAC,CAAC,CAAC,CAAC,UAAU,EAAE,CAAC;AAC7D,CAAC;AAED,IAAI,qBAAqB,GAAG,IAAI,GAAG,EAAE,CAAC;AAEtC,SAAS,KAAK,CACZ,IAAa,EAEb,KAAc,EACd,SAAiD,EACjD,IAAmB,EAAA;IAInB,IAAI,CAAC,IAAI,CAAC,OAAO;AAAE,QAAA,IAAI,CAAC,OAAO,GAAG,EAAE,CAAC;AAErC,IAAA,MAAM,IAAI,GAAG,IAAI,CAAC,QAAQ,EAAE,CAAC;AAE7B,IAAA,IAAI,CAAC,IAAI;AAAE,QAAA,OAAO,IAAI,CAAC;AAEvB,IAAA,IAAI,IAAI,CAAC,IAAI,KAAK,YAAY,EAAE;AAC9B,QAAA,MAAM,WAAW,GAAG,QAAQ,CAAC,IAAI,CAAC,CAAC;AAEnC,QAAA,IAAI,OAAY,CAAC;AAEjB,QAAA,OAAO,GAAG,SAAS,CAAC,mBAAmB,CAAC,WAAW,CAAC,EAAE;AACpD,YAAA,GAAG,IAAI;AACP,YAAA,MAAM,EAAE,gBAAgB;AACxB,YAAA,IAAI,EAAE,KAAK;AACZ,SAAA,CAAC,CAAC;AACH,QAAA,OAAO,GAAG,qBAAqB,CAAC,OAAO,CAAC,CAAC;QAOzC,OAAO;YACL,GAAG;YAKH,OAAO;YACP,GAAG;SACJ,CAAC;AACH,KAAA;IAGD,IAAI,IAAI,CAAC,IAAI,KAAK,WAAW,IAAI,IAAI,CAAC,IAAI,KAAK,YAAY,EAAE;QAC3D,MAAM,KAAK,GAAG,IAAI,CAAC,KAAK,CAAC,IAAI,EAAE,CAAC;QAChC,MAAM,IAAI,GAAG,IAAI,CAAC,IAAI,CAAC,IAAI,EAAE,CAAC;QAC9B,IAAI,aAAa,GAAG,SAAS,CAAC,mBAAmB,CAAC,KAAK,CAAC,EAAE;AACxD,YAAA,GAAG,IAAI;AACP,YAAA,MAAM,EAAE,gBAAgB;AACxB,YAAA,IAAI,EAAE,KAAK;AACZ,SAAA,CAAC,CAAC;AACH,QAAA,aAAa,GAAG,qBAAqB,CAAC,aAAa,CAAC,CAAC;AAIrD,QAAA,IAAI,IAAI,KAAK,KAAK,IAAI,IAAI,CAAC,mBAAmB,EAAE;YAC9C,OAAO,CAAC,IAAI,EAAE,GAAG,EAAE,aAAa,EAAE,GAAG,CAAC,CAAC;AACxC,SAAA;AACD,QAAA,OAAO,CAAC,IAAI,EAAE,IAAI,EAAE,GAAG,EAAE,GAAG,EAAE,aAAa,EAAE,GAAG,CAAC,CAAC;AACnD,KAAA;AA0BD,IAAA,IAAI,IAAI,CAAC,IAAI,KAAK,aAAa,EAAE;AAC/B,QAAA,qBAAqB,GAAG,eAAe,CAAC,IAAI,CAAC,KAAK,CAAC,CAAC;QACpD,OAAO;AACL,YAAA,KAAK,CAAC;gBACJ,KAAK;gBACL,QAAQ;AACR,gBAAA,SAAS,CAAC,IAAI,CAAC,KAAK,EAAE,EAAE,GAAG,IAAI,EAAE,MAAM,EAAE,YAAY,EAAE,CAAC;gBACxD,KAAK;gBACL,QAAQ;aACT,CAAC;YACF,QAAQ;SACT,CAAC;AACH,KAAA;IAGD,IAAI,IAAI,CAAC,IAAI,KAAK,SAAS,IAAI,IAAI,CAAC,IAAI,KAAK,QAAQ,EAAE;AACrD,QAAA,MAAM,aAAa,GAAG,QAAQ,CAAC,IAAI,CAAC,CAAC;AACrC,QAAA,IAAI,gBAAgB,GAAG,SAAS,CAAC,aAAa,EAAE;AAC9C,YAAA,GAAG,IAAI;AACP,YAAA,MAAM,EAAE,YAAY;AACrB,SAAA,CAAC,CAAC;AACH,QAAA,gBAAgB,GAAG,qBAAqB,CAAC,gBAAgB,CAAC,CAAC;QAG3D,MAAM,UAAU,GAAG,IAAI,CAAC,GAAG,CAAC,KAAK,EAAE,YAAY,CAAC,CAAC;QACjD,MAAM,UAAU,GAAG,KAAK,CAAC;YACvB,SAAS;AACT,YAAA,MAAM,CAAC,KAAK,CAAC,UAAU,CAAC,CAAC;YACzB,QAAQ;YACR,GAAG;AACJ,SAAA,CAAC,CAAC;QACH,OAAO;YACL,UAAU;AACV,YAAA,MAAM,CAAC,CAAC,QAAQ,EAAE,gBAAgB,CAAC,CAAC;YACpC,QAAQ;YACR,WAAW;SACZ,CAAC;AACH,KAAA;IAWD,IAAI,IAAI,CAAC,IAAI,KAAK,SAAS,IAAI,IAAI,CAAC,IAAI,KAAK,OAAO,EAAE;AACpD,QAAA,MAAM,eAAe,GAAG,QAAQ,CAAC,IAAI,CAAC,CAAC;QAEvC,MAAM,wBAAwB,GAAG,CAAC,KAAK,EAAE,MAAM,EAAE,MAAM,CAAC,CAAC;QACzD,IAAI,UAAU,GAAG,KAAK,CAAC;QAEvB,IAAI,IAAI,CAAC,UAAU,EAAE;AACnB,YAAA,MAAM,aAAa,GAAG,IAAI,CAAC,UAAU,CAAC,MAAM,CAAC,CAAC,CAAC,KAAK,CAAC,CAAC,IAAI,KAAK,MAAM,CAAC,CAAC;YACvE,IAAI,aAAa,CAAC,MAAM,EAAE;gBACxB,MAAM,SAAS,GAAG,aAAa,CAAC,CAAC,CAAC,CAAC,KAAK,CAAC,WAAW,EAAE,CAAC;AACvD,gBAAA,IAAI,wBAAwB,CAAC,QAAQ,CAAC,SAAS,CAAC;oBAC9C,UAAU,GAAG,SAAS,CAAC;AAC1B,aAAA;AACF,SAAA;AAED,QAAA,QAAQ,UAAU;AAChB,YAAA,KAAK,KAAK,CAAC;YACX,KAAK,MAAM,EAAE;AAGX,gBAAA,IAAI,eAAe,GAAG,SAAS,CAAC,eAAe,EAAE;AAC/C,oBAAA,GAAG,IAAI;AACP,oBAAA,MAAM,EAAE,UAAU;AACnB,iBAAA,CAAC,CAAC;AAEH,gBAAA,eAAe,GAAG,qBAAqB,CAAC,eAAe,CAAC,CAAC;gBAGzD,MAAM,UAAU,GAAG,IAAI,CAAC,GAAG,CAAC,KAAK,EAAE,YAAY,CAAC,CAAC;gBACjD,MAAM,UAAU,GAAG,KAAK,CAAC;oBACvB,QAAQ;AACR,oBAAA,MAAM,CAAC,KAAK,CAAC,UAAU,CAAC,CAAC;oBACzB,QAAQ;oBACR,GAAG;AACJ,iBAAA,CAAC,CAAC;gBACH,OAAO;oBACL,UAAU;AACV,oBAAA,MAAM,CAAC,CAAC,QAAQ,EAAE,eAAe,CAAC,CAAC;oBACnC,QAAQ;oBACR,UAAU;iBACX,CAAC;AACH,aAAA;YACD,KAAK,MAAM,EAAE;AACX,gBAAA,MAAM,UAAU,GACd,IAAI,CAAC,SAAS,CAAC,WAAW,EAAE,KAAK,MAAM,GAAG,MAAM,GAAG,IAAI,CAAC;AAC1D,gBAAA,MAAM,WAAW,GAAiC;oBAChD,OAAO,EAAE,IAAI,CAAC,QAAQ;AACtB,oBAAA,YAAY,EAAE,CAAC,IAAI,CAAC,OAAO;oBAC3B,UAAU;iBACX,CAAC;gBAGF,MAAM,EAAE,MAAM,EAAE,GAAG,EAAE,GAAG,YAAY,CAAC,eAAe,CAAC,CAAC;AAGtD,gBAAA,MAAM,qBAAqB,GAAGC,2BAAa,CAAC,MAAM,CAChD,GAAG,EACH,WAAW,CACZ,CAAC,IAAI,EAAE,CAAC;AAGT,gBAAA,MAAM,aAAa,GAAG,IAAI,CAAC,QAAQ,EAAE,qBAAqB,CAAC,KAAK,CAAC,IAAI,CAAC,CAAC,CAAC;gBACxE,MAAM,UAAU,GAAG,IAAI,CAAC,GAAG,CAAC,KAAK,EAAE,YAAY,CAAC,CAAC;gBACjD,MAAM,UAAU,GAAG,KAAK,CAAC;oBACvB,QAAQ;AACR,oBAAA,MAAM,CAAC,KAAK,CAAC,UAAU,CAAC,CAAC;oBACzB,QAAQ;oBACR,GAAG;AACJ,iBAAA,CAAC,CAAC;gBACH,OAAO;oBACL,UAAU;oBACV,MAAM,CAAC,KAAK,CAAC,CAAC,QAAQ,EAAE,aAAa,CAAC,CAAC,CAAC;oBACxC,QAAQ;oBACR,UAAU;iBACX,CAAC;AACH,aAAA;AACF,SAAA;AACF,KAAA;AAGD,IAAA,IAAI,IAAI,CAAC,IAAI,KAAK,WAAW,IAAI,qBAAqB,CAAC,GAAG,CAAC,IAAI,CAAC,IAAI,CAAC,EAAE;AACrE,QAAA,IAAI,OAAO,GAAG,QAAQ,CAAC,IAAI,CAAC,CAAC;QAG7B,OAAO,GAAG,OAAO,CAAC,OAAO,CAAC,OAAO,EAAE,IAAI,CAAC,CAAC;QACzC,MAAM,UAAU,GAAG,OAAO,CAAC,KAAK,CAAC,IAAI,CAAC,CAAC,GAAG,CAAC,CAAC,CAAC,KAAK,CAAC,CAAC,SAAS,EAAE,CAAC,CAAC;AACjE,QAAA,OAAO,GAAG,UAAU,CAAC,IAAI,CAAC,IAAI,CAAC,CAAC;AAGhC,QAAA,IAAI,kBAAkB,GAAG,SAAS,CAAC,OAAO,EAAE;AAC1C,YAAA,GAAG,IAAI;AACP,YAAA,MAAM,EAAE,UAAU;AACnB,SAAA,CAAC,CAAC;AACH,QAAA,kBAAkB,GAAG,qBAAqB,CAAC,kBAAkB,CAAC,CAAC;QAG/D,MAAM,UAAU,GAAG,IAAI,CAAC,GAAG,CAAC,KAAK,EAAE,YAAY,CAAC,CAAC;QACjD,MAAM,UAAU,GAAG,KAAK,CAAC;YACvB,CAAI,CAAA,EAAA,IAAI,CAAC,IAAI,CAAE,CAAA;AACf,YAAA,MAAM,CAAC,KAAK,CAAC,UAAU,CAAC,CAAC;YACzB,QAAQ;YACR,GAAG;AACJ,SAAA,CAAC,CAAC;QACH,OAAO;YACL,UAAU;YACV,MAAM,CAAC,KAAK,CAAC,CAAC,QAAQ,EAAE,kBAAkB,CAAC,CAAC,CAAC;YAC7C,QAAQ;YACR,CAAK,EAAA,EAAA,IAAI,CAAC,IAAI,CAAG,CAAA,CAAA;SAClB,CAAC;AACH,KAAA;AAED,IAAA,OAAO,IAAI,CAAC;AACd,CAAC;AAED,SAAS,iBAAiB,CAAC,IAAuB,EAAA;AAShD,IAAA,OAAO,KAAK,CAAC;AACf,CAAC;AAED,MAAM,OAAO,GAAY;IACvB,KAAK;IACL,YAAY;IACZ,KAAK;IACL,iBAAiB;CAClB;;ACjwBY,MAAA,OAAO,GAA+C;AACjE,IAAA,cAAc,EAAE;AACd,QAAA,KAAK,EAAE,OAAO;AACd,QAAA,QAAQ,EAAE,OAAO;AACjB,QAAA,IAAI,EAAE,QAAQ;AACd,QAAA,OAAO,EAAE,iBAAiB;AAC1B,QAAA,WAAW,EAAE,4CAA4C;AACzD,QAAA,OAAO,EAAE;AACP,YAAA;AACE,gBAAA,KAAK,EAAE,iBAAiB;AACxB,gBAAA,WAAW,EAAE,iBAAiB;AAC/B,aAAA;AACD,YAAA;AACE,gBAAA,KAAK,EAAE,iBAAiB;AACxB,gBAAA,WAAW,EAAE,iBAAiB;AAC/B,aAAA;AACF,SAAA;AACF,KAAA;AACD,IAAA,mBAAmB,EAAE;AACnB,QAAA,KAAK,EAAE,QAAQ;AACf,QAAA,QAAQ,EAAE,OAAO;AACjB,QAAA,IAAI,EAAE,SAAS;AACf,QAAA,OAAO,EAAE,KAAK;AACd,QAAA,WAAW,EACT,kFAAkF;AACrF,KAAA;;;AChCH,MAAMJ,SAAO,GAAGC,sBAAa,CAAC,mMAAe,CAAC,CAAC;AAG/C,MAAM,KAAK,GAAGC,oBAAY,CAACF,SAAO,CAAC,OAAO,CAAC,4BAA4B,CAAC,CAAC,CAAC;AAE7D,MAAA,SAAS,GAA+B;AACnD,IAAA;AACE,QAAA,IAAI,EAAE,OAAO;QACb,OAAO,EAAE,CAAC,OAAO,CAAC;QAClB,UAAU,EAAE,CAAC,QAAQ,CAAC;QACtB,iBAAiB,EAAE,CAAC,OAAO,CAAC;AAC7B,KAAA;EACD;AAEW,MAAA,OAAO,GAA2B;AAC7C,IAAA,KAAK,EAAE;QACL,KAAK,EAAE,CAAC,MAAM,KAAK,KAAK,CAAC,MAAM,CAAC;AAChC,QAAA,SAAS,EAAE,OAAO;QAClB,QAAQ,EAAE,CAAC,IAAI,KAAK,IAAI,CAAC,KAAK;QAC9B,MAAM,EAAE,CAAC,IAAI,KAAK,IAAI,CAAC,GAAG;AAC3B,KAAA;EACD;AAEW,MAAA,QAAQ,GAA4B;AAC/C,IAAA,KAAK,EAAE,OAAO;EACd;AAEF,MAAM,cAAc,GAAG;AACrB,IAAA,QAAQ,EAAE,CAAC;;;;;;;;;"}